{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to sankaku documentation","text":"<p>It is an unofficial API wrapper for Sankaku Complex with type-hinting, pydantic data validation and an optional logging support with loguru.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Type-hints</li> <li>Deserialization of raw json data thanks to pydantic models</li> <li>Enumerations for API request parameters to provide better user experience</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.8+</li> <li>aiohttp</li> <li>pydantic</li> <li>loguru</li> <li>aiohttp-retry</li> <li>typing_extensions; python_version &lt; '3.10'</li> </ul>"},{"location":"#installation","title":"Installation","text":""},{"location":"#installation-with-pip","title":"Installation with pip","text":"<p>To install sankaku via pip write following line of code in your terminal:</p> <pre><code>pip install sankaku\n</code></pre>"},{"location":"#installation-with-docker","title":"Installation with Docker","text":"<p>To install the sankaku via Docker, you can follow these steps:</p>"},{"location":"#step-1-install-docker","title":"Step 1: Install Docker","text":"<p>Ensure that Docker is installed on your machine. If Docker is not already installed, you can download and install it from the official Docker website.</p>"},{"location":"#step-2-use-docker-to-install-sankaku","title":"Step 2: Use docker to install sankaku","text":"<p>Open a command prompt. Navigate to the directory where you want to install sankaku. Type the following command:</p> <pre><code>git clone https://github.com/zerex290/sankaku.git\ncd sankaku\ndocker run -it --name sankaku -w /opt -v$(pwd):/opt python:3 bash\n</code></pre>"},{"location":"#usage-example","title":"Usage example","text":"<pre><code>import asyncio\nfrom sankaku import SankakuClient\nasync def main():\nclient = SankakuClient()\npost = await client.get_post(25742064)\nprint(f\"Rating: {post.rating} | Created: {post.created_at}\")\n# \"Rating: Rating.QUESTIONABLE | Created: 2021-08-01 23:18:52+03:00\"\nawait client.login(access_token=\"token\")\n# Or you can authorize by credentials:\n# await client.login(login=\"nickname or email\", password=\"password\")\n# Get the first 100 posts which have been added to favorites of the\n# currently logged-in user:\nasync for post in client.get_favorited_posts(100):\nprint(post)\n# Get every 3rd book from book pages, starting with 100th and ending with\n# 400th book:\nasync for book in client.browse_books(100, 401, 3):  # range specified in\nprint(book)                                      # same way as with 'range()'\nasyncio.run(main())\n</code></pre>"},{"location":"authorization/","title":"The authorization process","text":"<p>Authorization on Sankaku Complex can be performed in two ways:</p> <ul> <li>via access token</li> <li>via credentials (login and password)</li> </ul>"},{"location":"authorization/#note","title":"Note","text":"<p>It is not necessary to login into Sankaku Complex at all. You are free to send requests to server as unauthorized user, but in that case some methods will be unavailable to you (e.g. <code>get_favorited_posts()</code>, <code>get_favorited_books()</code> etc.).</p>"},{"location":"authorization/#authorization-via-access-token","title":"Authorization via access token","text":"<p>The following code block shows how to login into account using access token:</p> <pre><code>import asyncio\nimport os\nfrom sankaku import SankakuClient\nasync def main():\nclient = SankakuClient()\nawait client.login(access_token=os.getenv(\"ACCESS_TOKEN\"))\n# We're using virtual environment variables to prevent\n# private data from accidentally leaking.\n# ... Continue to work with API\nasyncio.run(main())\n</code></pre>"},{"location":"authorization/#authorization-via-credentials","title":"Authorization via credentials","text":"<p>Authorization method by credentials is the same as in previous example, but now user should pass two arguments to <code>login()</code> method:</p> <pre><code>import asyncio\nimport os\nfrom sankaku import SankakuClient\nasync def main():\nclient = SankakuClient()\nawait client.login(\nlogin=os.getenv(\"LOGIN\"), password=os.getenv(\"PASSWORD\")\n)\n# ... Continue to work with API\nasyncio.run(main())\n</code></pre>"},{"location":"authorization/#results","title":"Results","text":"<p>If authorization was successful, server will return response with serialized json data which will be processed by pydantic. After that user profile model will be passed to <code>client.profile</code> and all further requests to Sankaku servers will be performed on behalf of logged-in user.</p>"},{"location":"api/","title":"Introduction to sankaku API","text":"<p>This section describes main objects used by sankaku. Typedefs and constants are excluded from this section.</p>"},{"location":"api/errors/","title":"Documentation for sankaku's errors","text":""},{"location":"api/errors/#sankaku.errors.SankakuError","title":"<code>sankaku.errors.SankakuError</code>","text":"<p>             Bases: <code>Exception</code></p> Source code in <code>sankaku/errors.py</code> <pre><code>class SankakuError(Exception):\nmsg: str = \"\"\ndef __init__(self, msg: Optional[str] = None) -&gt; None:\n\"\"\"Base error class for raising exceptions without any special params.\"\"\"\nself.msg = msg or self.msg\ndef __repr__(self) -&gt; str:\nreturn repr(self.msg)\ndef __str__(self) -&gt; str:\nreturn str(self.msg)\n</code></pre>"},{"location":"api/errors/#sankaku.errors.SankakuError.__init__","title":"<code>__init__(msg=None)</code>","text":"<p>Base error class for raising exceptions without any special params.</p> Source code in <code>sankaku/errors.py</code> <pre><code>def __init__(self, msg: Optional[str] = None) -&gt; None:\n\"\"\"Base error class for raising exceptions without any special params.\"\"\"\nself.msg = msg or self.msg\n</code></pre>"},{"location":"api/errors/#sankaku.errors.RateLimitError","title":"<code>sankaku.errors.RateLimitError</code>","text":"<p>             Bases: <code>SankakuError</code></p> Source code in <code>sankaku/errors.py</code> <pre><code>class RateLimitError(SankakuError):\nmsg = \"Can't set both rps and rpm at once.\"\n</code></pre>"},{"location":"api/errors/#sankaku.errors.LoginRequirementError","title":"<code>sankaku.errors.LoginRequirementError</code>","text":"<p>             Bases: <code>SankakuError</code></p> Source code in <code>sankaku/errors.py</code> <pre><code>class LoginRequirementError(SankakuError):\nmsg = \"You must be logged-in.\"\n</code></pre>"},{"location":"api/errors/#sankaku.errors.VideoDurationError","title":"<code>sankaku.errors.VideoDurationError</code>","text":"<p>             Bases: <code>SankakuError</code></p> Source code in <code>sankaku/errors.py</code> <pre><code>class VideoDurationError(SankakuError):\nmsg = \"Argument is available only with video files.\"\n</code></pre>"},{"location":"api/errors/#sankaku.errors.PaginatorLastPage","title":"<code>sankaku.errors.PaginatorLastPage</code>","text":"<p>             Bases: <code>SankakuError</code></p> Source code in <code>sankaku/errors.py</code> <pre><code>class PaginatorLastPage(SankakuError):  # noqa: N818\nmsg = \"Last available page reached.\"\n</code></pre>"},{"location":"api/errors/#sankaku.errors.SankakuServerError","title":"<code>sankaku.errors.SankakuServerError</code>","text":"<p>             Bases: <code>SankakuError</code></p> Source code in <code>sankaku/errors.py</code> <pre><code>class SankakuServerError(SankakuError):\ndef __init__(\nself,\nstatus: Optional[int],\nmsg: Optional[str] = None,\n**kwargs\n) -&gt; None:\n\"\"\"Error class for parametrized exceptions.\"\"\"\nself.status = status\nself.kwargs = kwargs\nstr_kwargs = \", \".join(f\"{k}={v}\" for k, v in self.kwargs.items())\ndelimiter = \": \" if self.kwargs else \"\"\nself.msg = f\"[{self.status}] {msg or self.msg}{delimiter}{str_kwargs}.\"\ndef __repr__(self) -&gt; str:\nreturn repr(self.msg)\ndef __str__(self) -&gt; str:\nreturn str(self.msg)\n</code></pre>"},{"location":"api/errors/#sankaku.errors.SankakuServerError.__init__","title":"<code>__init__(status, msg=None, **kwargs)</code>","text":"<p>Error class for parametrized exceptions.</p> Source code in <code>sankaku/errors.py</code> <pre><code>def __init__(\nself,\nstatus: Optional[int],\nmsg: Optional[str] = None,\n**kwargs\n) -&gt; None:\n\"\"\"Error class for parametrized exceptions.\"\"\"\nself.status = status\nself.kwargs = kwargs\nstr_kwargs = \", \".join(f\"{k}={v}\" for k, v in self.kwargs.items())\ndelimiter = \": \" if self.kwargs else \"\"\nself.msg = f\"[{self.status}] {msg or self.msg}{delimiter}{str_kwargs}.\"\n</code></pre>"},{"location":"api/errors/#sankaku.errors.PageNotFoundError","title":"<code>sankaku.errors.PageNotFoundError</code>","text":"<p>             Bases: <code>SankakuServerError</code></p> Source code in <code>sankaku/errors.py</code> <pre><code>class PageNotFoundError(SankakuServerError):\nmsg = \"Failed to fetch page with requested params\"\n</code></pre>"},{"location":"api/errors/#sankaku.errors.AuthorizationError","title":"<code>sankaku.errors.AuthorizationError</code>","text":"<p>             Bases: <code>SankakuServerError</code></p> Source code in <code>sankaku/errors.py</code> <pre><code>class AuthorizationError(SankakuServerError):\nmsg = \"Authorization failed\"\n</code></pre>"},{"location":"api/types/","title":"Documentation for sankaku's <code>enum</code> types","text":""},{"location":"api/types/#sankaku.types.Rating","title":"<code>sankaku.types.Rating</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/types/#sankaku.types.Rating.SAFE","title":"<code>SAFE = 's'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.Rating.QUESTIONABLE","title":"<code>QUESTIONABLE = 'q'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.Rating.EXPLICIT","title":"<code>EXPLICIT = 'e'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.PostOrder","title":"<code>sankaku.types.PostOrder</code>","text":"<p>             Bases: <code>Enum</code></p>"},{"location":"api/types/#sankaku.types.PostOrder.POPULARITY","title":"<code>POPULARITY = 'popularity'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.PostOrder.DATE","title":"<code>DATE = 'date'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.PostOrder.QUALITY","title":"<code>QUALITY = 'quality'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.PostOrder.RANDOM","title":"<code>RANDOM = 'random'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.PostOrder.RECENTLY_FAVORITED","title":"<code>RECENTLY_FAVORITED = 'recently_favorited'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.PostOrder.RECENTLY_VOTED","title":"<code>RECENTLY_VOTED = 'recently_voted'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.SortParameter","title":"<code>sankaku.types.SortParameter</code>","text":"<p>             Bases: <code>Enum</code></p>"},{"location":"api/types/#sankaku.types.SortParameter.NAME","title":"<code>NAME = 'name'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.SortParameter.TRANSLATIONS","title":"<code>TRANSLATIONS = 'name_ja'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.SortParameter.TYPE","title":"<code>TYPE = 'type'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.SortParameter.RATING","title":"<code>RATING = 'rating'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.SortParameter.BOOK_COUNT","title":"<code>BOOK_COUNT = 'pool_count'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.SortParameter.POST_COUNT","title":"<code>POST_COUNT = 'count'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.SortDirection","title":"<code>sankaku.types.SortDirection</code>","text":"<p>             Bases: <code>Enum</code></p>"},{"location":"api/types/#sankaku.types.SortDirection.ASC","title":"<code>ASC = 'asc'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.SortDirection.DESC","title":"<code>DESC = 'desc'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.TagOrder","title":"<code>sankaku.types.TagOrder</code>","text":"<p>             Bases: <code>Enum</code></p>"},{"location":"api/types/#sankaku.types.TagOrder.POPULARITY","title":"<code>POPULARITY = 'popularity'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.TagOrder.QUALITY","title":"<code>QUALITY = 'quality'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.TagType","title":"<code>sankaku.types.TagType</code>","text":"<p>             Bases: <code>Enum</code></p>"},{"location":"api/types/#sankaku.types.TagType.ARTIST","title":"<code>ARTIST = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.TagType.COPYRIGHT","title":"<code>COPYRIGHT = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.TagType.CHARACTER","title":"<code>CHARACTER = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.TagType.GENERAL","title":"<code>GENERAL = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.TagType.MEDIUM","title":"<code>MEDIUM = 8</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.TagType.META","title":"<code>META = 9</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.TagType.GENRE","title":"<code>GENRE = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.TagType.STUDIO","title":"<code>STUDIO = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.FileType","title":"<code>sankaku.types.FileType</code>","text":"<p>             Bases: <code>Enum</code></p>"},{"location":"api/types/#sankaku.types.FileType.IMAGE","title":"<code>IMAGE = 'image'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.FileType.GIF","title":"<code>GIF = 'gif'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.FileType.VIDEO","title":"<code>VIDEO = 'video'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.FileSize","title":"<code>sankaku.types.FileSize</code>","text":"<p>             Bases: <code>Enum</code></p>"},{"location":"api/types/#sankaku.types.FileSize.LARGE","title":"<code>LARGE = 'large_filesize'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.FileSize.HUGE","title":"<code>HUGE = 'extremely_large_filesize'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.FileSize.LONG","title":"<code>LONG = 'long_image'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.FileSize.WALLPAPER","title":"<code>WALLPAPER = 'wallpaper'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.FileSize.A_RATIO_16_9","title":"<code>A_RATIO_16_9 = '16:9_aspect_ratio'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.FileSize.A_RATIO_4_3","title":"<code>A_RATIO_4_3 = '4:3_aspect_ratio'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.FileSize.A_RATIO_3_2","title":"<code>A_RATIO_3_2 = '3:2_aspect_ratio'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.FileSize.A_RATIO_1_1","title":"<code>A_RATIO_1_1 = '1:1_aspect_ratio'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.UserOrder","title":"<code>sankaku.types.UserOrder</code>","text":"<p>             Bases: <code>Enum</code></p>"},{"location":"api/types/#sankaku.types.UserOrder.POSTS","title":"<code>POSTS = 'post_upload_count'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.UserOrder.FAVORITES","title":"<code>FAVORITES = 'favorite_count'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.UserOrder.NAME","title":"<code>NAME = 'name'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.UserOrder.NEWEST","title":"<code>NEWEST = 'newest'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.UserOrder.OLDEST","title":"<code>OLDEST = 'oldest'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.UserOrder.LAST_SEEN","title":"<code>LAST_SEEN = 'active'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.UserLevel","title":"<code>sankaku.types.UserLevel</code>","text":"<p>             Bases: <code>Enum</code></p>"},{"location":"api/types/#sankaku.types.UserLevel.ADMIN","title":"<code>ADMIN = 50</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.UserLevel.SYSTEM_USER","title":"<code>SYSTEM_USER = 45</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.UserLevel.MODERATOR","title":"<code>MODERATOR = 40</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.UserLevel.JANITOR","title":"<code>JANITOR = 35</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.UserLevel.CONTRIBUTOR","title":"<code>CONTRIBUTOR = 33</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.UserLevel.PRIVILEGED","title":"<code>PRIVILEGED = 30</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.UserLevel.MEMBER","title":"<code>MEMBER = 20</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.UserLevel.BLOCKED","title":"<code>BLOCKED = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.UserLevel.UNACTIVATED","title":"<code>UNACTIVATED = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.BookOrder","title":"<code>sankaku.types.BookOrder</code>","text":"<p>             Bases: <code>Enum</code></p>"},{"location":"api/types/#sankaku.types.BookOrder.DATE","title":"<code>DATE = 'date'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.BookOrder.QUALITY","title":"<code>QUALITY = 'quality'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.BookOrder.RANDOM","title":"<code>RANDOM = 'random'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.BookOrder.RECENTLY_FAVORITED","title":"<code>RECENTLY_FAVORITED = 'recently_favorited'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.BookOrder.RECENTLY_VOTED","title":"<code>RECENTLY_VOTED = 'recently_voted'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/utils/","title":"Documentation for miscellaneous support functions","text":""},{"location":"api/utils/#sankaku.utils.ratelimit","title":"<code>sankaku.utils.ratelimit(*, rps=None, rpm=None)</code>","text":"<p>Limit the number of requests.</p> <p>Parameters:</p> Name Type Description Default <code>rps</code> <code>Optional[int]</code> <p>Request per second</p> <code>None</code> <code>rpm</code> <code>Optional[int]</code> <p>Requests per minute</p> <code>None</code> Source code in <code>sankaku/utils.py</code> <pre><code>def ratelimit(\n*,\nrps: Optional[int] = None,\nrpm: Optional[int] = None\n) -&gt; Callable[[Callable[_P, Awaitable[_T]]], Callable[_P, Awaitable[_T]]]:\n\"\"\"Limit the number of requests.\n    Args:\n        rps: Request per second\n        rpm: Requests per minute\n    \"\"\"\nif all(locals().values()):\nraise RateLimitError\nelif not any(locals().values()):\nraise TypeError(\"At least one argument must be specified.\")\nsleep_time: float = (1 / rps) if rps else (60 / rpm)  # type: ignore\ndef wrapper(func: Callable[_P, Awaitable[_T]]) -&gt; Callable[_P, Awaitable[_T]]:\n@wraps(func)\nasync def inner(*args: _P.args, **kwargs: _P.kwargs) -&gt; _T:\nawait asyncio.sleep(sleep_time)\nreturn await func(*args, **kwargs)\nreturn inner\nreturn wrapper\n</code></pre>"},{"location":"api/utils/#sankaku.utils.convert_ts_to_datetime","title":"<code>sankaku.utils.convert_ts_to_datetime(ts)</code>","text":"<p>Convert timestamp in datetime dict into datetime class.</p> Source code in <code>sankaku/utils.py</code> <pre><code>def convert_ts_to_datetime(ts: Timestamp) -&gt; Optional[datetime]:\n\"\"\"Convert timestamp in datetime dict into datetime class.\"\"\"\nif ts.get(\"s\") is None:\nreturn None\nreturn datetime.utcfromtimestamp(ts[\"s\"]).astimezone()  # type: ignore\n</code></pre>"},{"location":"api/clients/abc/","title":"Documentation for <code>abc.py</code>","text":""},{"location":"api/clients/abc/#sankaku.clients.abc.ABCHttpClient","title":"<code>sankaku.clients.abc.ABCHttpClient</code>","text":"<p>             Bases: <code>ABC</code></p> Source code in <code>sankaku/clients/abc.py</code> <pre><code>class ABCHttpClient(ABC):\n@abstractmethod\ndef __init__(self, *args, **kwargs) -&gt; None:\n\"\"\"Abstract client for handling http requests.\"\"\"\npass\nasync def __aenter__(self):\nreturn self\nasync def __aexit__(self, exc_type, exc_val, exc_tb) -&gt; None:\nawait self.close()\n@abstractmethod\ndef __del__(self) -&gt; None:\npass\n@abstractmethod\nasync def close(self) -&gt; None:\n\"\"\"Close previously created client session.\"\"\"\n@abstractmethod\nasync def request(self, method: str, url: str, **kwargs) -&gt; ClientResponse:\n\"\"\"Make request to specified url.\"\"\"\n</code></pre>"},{"location":"api/clients/abc/#sankaku.clients.abc.ABCHttpClient.close","title":"<code>close()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Close previously created client session.</p> Source code in <code>sankaku/clients/abc.py</code> <pre><code>@abstractmethod\nasync def close(self) -&gt; None:\n\"\"\"Close previously created client session.\"\"\"\n</code></pre>"},{"location":"api/clients/abc/#sankaku.clients.abc.ABCHttpClient.request","title":"<code>request(method, url, **kwargs)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Make request to specified url.</p> Source code in <code>sankaku/clients/abc.py</code> <pre><code>@abstractmethod\nasync def request(self, method: str, url: str, **kwargs) -&gt; ClientResponse:\n\"\"\"Make request to specified url.\"\"\"\n</code></pre>"},{"location":"api/clients/abc/#sankaku.clients.abc.ABCClient","title":"<code>sankaku.clients.abc.ABCClient</code>","text":"<p>             Bases: <code>ABC</code></p> Source code in <code>sankaku/clients/abc.py</code> <pre><code>class ABCClient(ABC):\n@abstractmethod\ndef __init__(self, *args, **kwargs) -&gt; None:\n\"\"\"Abstract Sankaku client.\"\"\"\npass\n@abstractmethod\nasync def login(\nself,\n*,\naccess_token: Optional[str] = None,\nlogin: Optional[str] = None,\npassword: Optional[str] = None\n) -&gt; None:\n\"\"\"Login into sankakucomplex.com via access token or credentials.\"\"\"\n</code></pre>"},{"location":"api/clients/abc/#sankaku.clients.abc.ABCClient.login","title":"<code>login(*, access_token=None, login=None, password=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Login into sankakucomplex.com via access token or credentials.</p> Source code in <code>sankaku/clients/abc.py</code> <pre><code>@abstractmethod\nasync def login(\nself,\n*,\naccess_token: Optional[str] = None,\nlogin: Optional[str] = None,\npassword: Optional[str] = None\n) -&gt; None:\n\"\"\"Login into sankakucomplex.com via access token or credentials.\"\"\"\n</code></pre>"},{"location":"api/clients/clients/","title":"Documentation for <code>clients.py</code>","text":""},{"location":"api/clients/clients/#sankaku.clients.clients.BaseClient","title":"<code>sankaku.clients.clients.BaseClient</code>","text":"<p>             Bases: <code>ABCClient</code></p> Source code in <code>sankaku/clients/clients.py</code> <pre><code>class BaseClient(ABCClient):\ndef __init__(self) -&gt; None:\n\"\"\"Base client used for login.\"\"\"\nself._profile: Optional[mdl.ExtendedUser] = None\nself._http_client: HttpClient = HttpClient()\nself._access_token: Optional[str] = None  # TODO: ability to update access token\nself._token_type: Optional[str] = None\nasync def _login_via_credentials(self, login: str, password: str) -&gt; None:\nresponse = await self._http_client.post(\nconst.LOGIN_URL,\ndata=json.dumps({\"login\": login, \"password\": password})\n)\nif not response.ok:\nraise errors.AuthorizationError(response.status, **response.json)\nself._access_token = response.json[\"access_token\"]\nself._token_type = response.json[\"token_type\"]\nself._profile = mdl.ExtendedUser(**response.json[\"current_user\"])\nasync def _login_via_access_token(self, access_token: str) -&gt; None:\ntry:\nself._profile = await self._get_profile(access_token)\n# Update access token and token type after successful profile fetch\nself._access_token = access_token\nself._token_type = const.DEFAULT_TOKEN_TYPE\nexcept errors.SankakuServerError as e:\nraise errors.AuthorizationError(e.status, **e.kwargs)\nasync def _get_profile(self, access_token: str) -&gt; mdl.ExtendedUser:\n\"\"\"Get user profile information from Sankaku server by access token.\"\"\"\nif self._profile is not None:\nreturn self._profile\nheaders = {\"authorization\": f\"{const.DEFAULT_TOKEN_TYPE} {access_token}\"}\nheaders.update(self._http_client.headers)\nresponse = await self._http_client.get(const.PROFILE_URL, headers=headers)\nif not response.ok:\nraise errors.SankakuServerError(\nresponse.status, \"Failed to get user profile\", **response.json\n)\nreturn mdl.ExtendedUser(**response.json[\"user\"])\nasync def login(\nself,\n*,\naccess_token: Optional[str] = None,\nlogin: Optional[str] = None,\npassword: Optional[str] = None\n) -&gt; None:\n\"\"\"Login into sankakucomplex.com via access token or credentials.\n        In case when all arguments are specified, preference will be given\n        to authorization by credentials.\n        Args:\n            access_token: User access token\n            login: User email or nickname\n            password: User password\n        \"\"\"\nif login and password:\nawait self._login_via_credentials(login, password)\nelif access_token and not login and not password:\nawait self._login_via_access_token(access_token)\nelse:\nraise errors.SankakuError(\n\"The given data is not enough \"\n\"or invalid (perhaps of the wrong type).\"\n)\nself._http_client.headers.update(\nauthorization=f\"{self._token_type} {self._access_token}\"\n)\nlogger.info(f\"Successfully logged in as {self._profile.name}.\")  # type: ignore\n@property\ndef profile(self) -&gt; Optional[mdl.ExtendedUser]:\nreturn self._profile\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.BaseClient.login","title":"<code>login(*, access_token=None, login=None, password=None)</code>  <code>async</code>","text":"<p>Login into sankakucomplex.com via access token or credentials. In case when all arguments are specified, preference will be given to authorization by credentials.</p> <p>Parameters:</p> Name Type Description Default <code>access_token</code> <code>Optional[str]</code> <p>User access token</p> <code>None</code> <code>login</code> <code>Optional[str]</code> <p>User email or nickname</p> <code>None</code> <code>password</code> <code>Optional[str]</code> <p>User password</p> <code>None</code> Source code in <code>sankaku/clients/clients.py</code> <pre><code>async def login(\nself,\n*,\naccess_token: Optional[str] = None,\nlogin: Optional[str] = None,\npassword: Optional[str] = None\n) -&gt; None:\n\"\"\"Login into sankakucomplex.com via access token or credentials.\n    In case when all arguments are specified, preference will be given\n    to authorization by credentials.\n    Args:\n        access_token: User access token\n        login: User email or nickname\n        password: User password\n    \"\"\"\nif login and password:\nawait self._login_via_credentials(login, password)\nelif access_token and not login and not password:\nawait self._login_via_access_token(access_token)\nelse:\nraise errors.SankakuError(\n\"The given data is not enough \"\n\"or invalid (perhaps of the wrong type).\"\n)\nself._http_client.headers.update(\nauthorization=f\"{self._token_type} {self._access_token}\"\n)\nlogger.info(f\"Successfully logged in as {self._profile.name}.\")  # type: ignore\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.PostClient","title":"<code>sankaku.clients.clients.PostClient</code>","text":"<p>             Bases: <code>BaseClient</code></p> <p>Client for post browsing.</p> Source code in <code>sankaku/clients/clients.py</code> <pre><code>class PostClient(BaseClient):\n\"\"\"Client for post browsing.\"\"\"\nasync def browse_posts(\nself,\n_start: int,\n_stop: Optional[int] = None,\n_step: Optional[int] = None,\n/,\n*,\norder: Optional[types.PostOrder] = None,\ndate: Optional[List[datetime]] = None,\nrating: Optional[types.Rating] = None,\nthreshold: Optional[Annotated[int, ValueRange(1, 100)]] = None,\nhide_posts_in_books: Optional[Literal[\"in-larger-tags\", \"always\"]] = None,\nfile_size: Optional[types.FileSize] = None,\nfile_type: Optional[types.FileType] = None,\nvideo_duration: Optional[List[int]] = None,\nrecommended_for: Optional[str] = None,\nfavorited_by: Optional[str] = None,\ntags: Optional[List[str]] = None,\nadded_by: Optional[List[str]] = None,\nvoted: Optional[str] = None\n) -&gt; AsyncIterator[mdl.Post]:\n\"\"\"Get get a certain range of posts with specific characteristics.\n        Range of posts can be specified in the same way as when using built-in\n        `range()`.\n        Args:\n            _start: Start of the sequence\n            _stop: End of the sequence (except this value itself)\n            _step: Step of the sequence\n            order: Post order rule\n            date: Date or range of dates\n            rating: Post rating\n            threshold: Vote (quality) filter of posts\n            hide_posts_in_books: Whether show post from books or not\n            file_size: Size (aspect ratio) of mediafile\n            file_type: Type of mediafile in post\n            video_duration: Video duration in seconds or in range of seconds\n            recommended_for: Posts recommended for specified user\n            favorited_by: Posts favorited by specified user\n            tags: Tags available for search\n            added_by: Posts uploaded by specified users\n            voted: Posts voted by specified user\n        \"\"\"\nitem_range = _process_item_range(_start, _stop, _step)\npage_range = _process_page_range(*item_range[:2], limit=const.BASE_LIMIT)\nslices = _compute_slices(item_range, page_range)\nasync for page in PostPaginator(  # noqa: F405\n*page_range,\nhttp_client=self._http_client,\norder=order,\ndate=date,\nrating=rating,\nthreshold=threshold,\nhide_posts_in_books=hide_posts_in_books,\nfile_size=file_size,\nfile_type=file_type,\nvideo_duration=video_duration,\nrecommended_for=recommended_for,\nfavorited_by=favorited_by,\ntags=tags,\nadded_by=added_by,\nvoted=voted\n):\nfor post in page.items[slices.pop()]:\nyield post\nasync def get_favorited_posts(\nself,\n_start: int,\n_stop: Optional[int] = None,\n_step: Optional[int] = None,\n/\n) -&gt; AsyncIterator[mdl.Post]:\n\"\"\"Shorthand way to get a certain range of favorited posts of\n        currently logged-in user.\n        Range of posts can be specified in the same way as when using built-in\n        `range()`.\n        Args:\n            _start: Start of the sequence\n            _stop: End of the sequence (except this value itself)\n            _step: Step of the sequence\n        \"\"\"\nif self._profile is None:\nraise errors.LoginRequirementError\nasync for post in self.browse_posts(\n_start, _stop, _step,\nfavorited_by=self._profile.name\n):\nyield post\nasync def get_top_posts(\nself,\n_start: int,\n_stop: Optional[int] = None,\n_step: Optional[int] = None,\n/\n) -&gt; AsyncIterator[mdl.Post]:\n\"\"\"Shorthand way to get a certain range of top posts.\n        Range of posts can be specified in the same way as when using built-in\n        `range()`.\n        Args:\n            _start: Start of the sequence\n            _stop: End of the sequence (except this value itself)\n            _step: Step of the sequence\n        \"\"\"\nasync for post in self.browse_posts(\n_start, _stop, _step,\norder=types.PostOrder.QUALITY\n):\nyield post\nasync def get_popular_posts(\nself,\n_start: int,\n_stop: Optional[int] = None,\n_step: Optional[int] = None,\n/\n) -&gt; AsyncIterator[mdl.Post]:\n\"\"\"Shorthand way to get a certain range of popular posts.\n        Range of posts can be specified in the same way as when using built-in\n        `range()`.\n        Args:\n            _start: Start of the sequence\n            _stop: End of the sequence (except this value itself)\n            _step: Step of the sequence\n        \"\"\"\nasync for post in self.browse_posts(\n_start, _stop, _step,\norder=types.PostOrder.POPULARITY\n):\nyield post\nasync def get_recommended_posts(\nself,\n_start: int,\n_stop: Optional[int] = None,\n_step: Optional[int] = None,\n/\n) -&gt; AsyncIterator[mdl.Post]:\n\"\"\"Shorthand way to get a certain range of recommended posts for\n        currently logged-in user.\n        Range of posts can be specified in the same way as when using built-in\n        `range()`.\n        Args:\n            _start: Start of the sequence\n            _stop: End of the sequence (except this value itself)\n            _step: Step of the sequence\n        \"\"\"\nif self._profile is None:\nraise errors.LoginRequirementError\nasync for post in self.browse_posts(\n_start, _stop, _step,\nrecommended_for=self._profile.name\n):\nyield post\nasync def get_similar_posts(\nself,\n_start: int,\n_stop: Optional[int] = None,\n_step: Optional[int] = None,\n/,\n*,\npost_id: int\n) -&gt; AsyncIterator[mdl.Post]:\n\"\"\"Get a certain range of posts similar (recommended) for specific post.\n        Range of posts can be specified in the same way as when using built-in\n        `range()`.\n        Args:\n            _start: Start of the sequence\n            _stop: End of the sequence (except this value itself)\n            _step: Step of the sequence\n            post_id: ID of the post of interest\n        \"\"\"\nasync for post in self.browse_posts(\n_start, _stop, _step,\ntags=[f\"recommended_for_post:{post_id}\"]\n):\nyield post\nasync def get_post_comments(self, post_id: int) -&gt; AsyncIterator[mdl.Comment]:\n\"\"\"Get all comments of the specific post by its ID.\"\"\"\nasync for page in Paginator(  # noqa: F405\nconst.LAST_RANGE_ITEM,\nhttp_client=self._http_client,\nurl=const.COMMENTS_URL.format(post_id=post_id),\nmodel=mdl.Comment\n):\nfor comment in page.items:\nyield comment\nasync def get_post(self, post_id: int) -&gt; mdl.Post:\n\"\"\"Get specific post by its ID.\"\"\"\nresponse = await self._http_client.get(const.POST_URL.format(post_id=post_id))\nif not response.ok:\nraise errors.PageNotFoundError(response.status, post_id=post_id)\nreturn mdl.Post(**response.json)\nasync def create_post(self):  # TODO: TBA  # noqa: D102\nraise NotImplementedError\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.PostClient.browse_posts","title":"<code>browse_posts(_start, _stop=None, _step=None, /, *, order=None, date=None, rating=None, threshold=None, hide_posts_in_books=None, file_size=None, file_type=None, video_duration=None, recommended_for=None, favorited_by=None, tags=None, added_by=None, voted=None)</code>  <code>async</code>","text":"<p>Get get a certain range of posts with specific characteristics. Range of posts can be specified in the same way as when using built-in <code>range()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>_start</code> <code>int</code> <p>Start of the sequence</p> required <code>_stop</code> <code>Optional[int]</code> <p>End of the sequence (except this value itself)</p> <code>None</code> <code>_step</code> <code>Optional[int]</code> <p>Step of the sequence</p> <code>None</code> <code>order</code> <code>Optional[types.PostOrder]</code> <p>Post order rule</p> <code>None</code> <code>date</code> <code>Optional[List[datetime]]</code> <p>Date or range of dates</p> <code>None</code> <code>rating</code> <code>Optional[types.Rating]</code> <p>Post rating</p> <code>None</code> <code>threshold</code> <code>Optional[Annotated[int, ValueRange(1, 100)]]</code> <p>Vote (quality) filter of posts</p> <code>None</code> <code>hide_posts_in_books</code> <code>Optional[Literal['in-larger-tags', 'always']]</code> <p>Whether show post from books or not</p> <code>None</code> <code>file_size</code> <code>Optional[types.FileSize]</code> <p>Size (aspect ratio) of mediafile</p> <code>None</code> <code>file_type</code> <code>Optional[types.FileType]</code> <p>Type of mediafile in post</p> <code>None</code> <code>video_duration</code> <code>Optional[List[int]]</code> <p>Video duration in seconds or in range of seconds</p> <code>None</code> <code>recommended_for</code> <code>Optional[str]</code> <p>Posts recommended for specified user</p> <code>None</code> <code>favorited_by</code> <code>Optional[str]</code> <p>Posts favorited by specified user</p> <code>None</code> <code>tags</code> <code>Optional[List[str]]</code> <p>Tags available for search</p> <code>None</code> <code>added_by</code> <code>Optional[List[str]]</code> <p>Posts uploaded by specified users</p> <code>None</code> <code>voted</code> <code>Optional[str]</code> <p>Posts voted by specified user</p> <code>None</code> Source code in <code>sankaku/clients/clients.py</code> <pre><code>async def browse_posts(\nself,\n_start: int,\n_stop: Optional[int] = None,\n_step: Optional[int] = None,\n/,\n*,\norder: Optional[types.PostOrder] = None,\ndate: Optional[List[datetime]] = None,\nrating: Optional[types.Rating] = None,\nthreshold: Optional[Annotated[int, ValueRange(1, 100)]] = None,\nhide_posts_in_books: Optional[Literal[\"in-larger-tags\", \"always\"]] = None,\nfile_size: Optional[types.FileSize] = None,\nfile_type: Optional[types.FileType] = None,\nvideo_duration: Optional[List[int]] = None,\nrecommended_for: Optional[str] = None,\nfavorited_by: Optional[str] = None,\ntags: Optional[List[str]] = None,\nadded_by: Optional[List[str]] = None,\nvoted: Optional[str] = None\n) -&gt; AsyncIterator[mdl.Post]:\n\"\"\"Get get a certain range of posts with specific characteristics.\n    Range of posts can be specified in the same way as when using built-in\n    `range()`.\n    Args:\n        _start: Start of the sequence\n        _stop: End of the sequence (except this value itself)\n        _step: Step of the sequence\n        order: Post order rule\n        date: Date or range of dates\n        rating: Post rating\n        threshold: Vote (quality) filter of posts\n        hide_posts_in_books: Whether show post from books or not\n        file_size: Size (aspect ratio) of mediafile\n        file_type: Type of mediafile in post\n        video_duration: Video duration in seconds or in range of seconds\n        recommended_for: Posts recommended for specified user\n        favorited_by: Posts favorited by specified user\n        tags: Tags available for search\n        added_by: Posts uploaded by specified users\n        voted: Posts voted by specified user\n    \"\"\"\nitem_range = _process_item_range(_start, _stop, _step)\npage_range = _process_page_range(*item_range[:2], limit=const.BASE_LIMIT)\nslices = _compute_slices(item_range, page_range)\nasync for page in PostPaginator(  # noqa: F405\n*page_range,\nhttp_client=self._http_client,\norder=order,\ndate=date,\nrating=rating,\nthreshold=threshold,\nhide_posts_in_books=hide_posts_in_books,\nfile_size=file_size,\nfile_type=file_type,\nvideo_duration=video_duration,\nrecommended_for=recommended_for,\nfavorited_by=favorited_by,\ntags=tags,\nadded_by=added_by,\nvoted=voted\n):\nfor post in page.items[slices.pop()]:\nyield post\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.PostClient.get_favorited_posts","title":"<code>get_favorited_posts(_start, _stop=None, _step=None)</code>  <code>async</code>","text":"<p>Shorthand way to get a certain range of favorited posts of currently logged-in user. Range of posts can be specified in the same way as when using built-in <code>range()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>_start</code> <code>int</code> <p>Start of the sequence</p> required <code>_stop</code> <code>Optional[int]</code> <p>End of the sequence (except this value itself)</p> <code>None</code> <code>_step</code> <code>Optional[int]</code> <p>Step of the sequence</p> <code>None</code> Source code in <code>sankaku/clients/clients.py</code> <pre><code>async def get_favorited_posts(\nself,\n_start: int,\n_stop: Optional[int] = None,\n_step: Optional[int] = None,\n/\n) -&gt; AsyncIterator[mdl.Post]:\n\"\"\"Shorthand way to get a certain range of favorited posts of\n    currently logged-in user.\n    Range of posts can be specified in the same way as when using built-in\n    `range()`.\n    Args:\n        _start: Start of the sequence\n        _stop: End of the sequence (except this value itself)\n        _step: Step of the sequence\n    \"\"\"\nif self._profile is None:\nraise errors.LoginRequirementError\nasync for post in self.browse_posts(\n_start, _stop, _step,\nfavorited_by=self._profile.name\n):\nyield post\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.PostClient.get_top_posts","title":"<code>get_top_posts(_start, _stop=None, _step=None)</code>  <code>async</code>","text":"<p>Shorthand way to get a certain range of top posts. Range of posts can be specified in the same way as when using built-in <code>range()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>_start</code> <code>int</code> <p>Start of the sequence</p> required <code>_stop</code> <code>Optional[int]</code> <p>End of the sequence (except this value itself)</p> <code>None</code> <code>_step</code> <code>Optional[int]</code> <p>Step of the sequence</p> <code>None</code> Source code in <code>sankaku/clients/clients.py</code> <pre><code>async def get_top_posts(\nself,\n_start: int,\n_stop: Optional[int] = None,\n_step: Optional[int] = None,\n/\n) -&gt; AsyncIterator[mdl.Post]:\n\"\"\"Shorthand way to get a certain range of top posts.\n    Range of posts can be specified in the same way as when using built-in\n    `range()`.\n    Args:\n        _start: Start of the sequence\n        _stop: End of the sequence (except this value itself)\n        _step: Step of the sequence\n    \"\"\"\nasync for post in self.browse_posts(\n_start, _stop, _step,\norder=types.PostOrder.QUALITY\n):\nyield post\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.PostClient.get_popular_posts","title":"<code>get_popular_posts(_start, _stop=None, _step=None)</code>  <code>async</code>","text":"<p>Shorthand way to get a certain range of popular posts. Range of posts can be specified in the same way as when using built-in <code>range()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>_start</code> <code>int</code> <p>Start of the sequence</p> required <code>_stop</code> <code>Optional[int]</code> <p>End of the sequence (except this value itself)</p> <code>None</code> <code>_step</code> <code>Optional[int]</code> <p>Step of the sequence</p> <code>None</code> Source code in <code>sankaku/clients/clients.py</code> <pre><code>async def get_popular_posts(\nself,\n_start: int,\n_stop: Optional[int] = None,\n_step: Optional[int] = None,\n/\n) -&gt; AsyncIterator[mdl.Post]:\n\"\"\"Shorthand way to get a certain range of popular posts.\n    Range of posts can be specified in the same way as when using built-in\n    `range()`.\n    Args:\n        _start: Start of the sequence\n        _stop: End of the sequence (except this value itself)\n        _step: Step of the sequence\n    \"\"\"\nasync for post in self.browse_posts(\n_start, _stop, _step,\norder=types.PostOrder.POPULARITY\n):\nyield post\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.PostClient.get_recommended_posts","title":"<code>get_recommended_posts(_start, _stop=None, _step=None)</code>  <code>async</code>","text":"<p>Shorthand way to get a certain range of recommended posts for currently logged-in user. Range of posts can be specified in the same way as when using built-in <code>range()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>_start</code> <code>int</code> <p>Start of the sequence</p> required <code>_stop</code> <code>Optional[int]</code> <p>End of the sequence (except this value itself)</p> <code>None</code> <code>_step</code> <code>Optional[int]</code> <p>Step of the sequence</p> <code>None</code> Source code in <code>sankaku/clients/clients.py</code> <pre><code>async def get_recommended_posts(\nself,\n_start: int,\n_stop: Optional[int] = None,\n_step: Optional[int] = None,\n/\n) -&gt; AsyncIterator[mdl.Post]:\n\"\"\"Shorthand way to get a certain range of recommended posts for\n    currently logged-in user.\n    Range of posts can be specified in the same way as when using built-in\n    `range()`.\n    Args:\n        _start: Start of the sequence\n        _stop: End of the sequence (except this value itself)\n        _step: Step of the sequence\n    \"\"\"\nif self._profile is None:\nraise errors.LoginRequirementError\nasync for post in self.browse_posts(\n_start, _stop, _step,\nrecommended_for=self._profile.name\n):\nyield post\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.PostClient.get_similar_posts","title":"<code>get_similar_posts(_start, _stop=None, _step=None, /, *, post_id)</code>  <code>async</code>","text":"<p>Get a certain range of posts similar (recommended) for specific post. Range of posts can be specified in the same way as when using built-in <code>range()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>_start</code> <code>int</code> <p>Start of the sequence</p> required <code>_stop</code> <code>Optional[int]</code> <p>End of the sequence (except this value itself)</p> <code>None</code> <code>_step</code> <code>Optional[int]</code> <p>Step of the sequence</p> <code>None</code> <code>post_id</code> <code>int</code> <p>ID of the post of interest</p> required Source code in <code>sankaku/clients/clients.py</code> <pre><code>async def get_similar_posts(\nself,\n_start: int,\n_stop: Optional[int] = None,\n_step: Optional[int] = None,\n/,\n*,\npost_id: int\n) -&gt; AsyncIterator[mdl.Post]:\n\"\"\"Get a certain range of posts similar (recommended) for specific post.\n    Range of posts can be specified in the same way as when using built-in\n    `range()`.\n    Args:\n        _start: Start of the sequence\n        _stop: End of the sequence (except this value itself)\n        _step: Step of the sequence\n        post_id: ID of the post of interest\n    \"\"\"\nasync for post in self.browse_posts(\n_start, _stop, _step,\ntags=[f\"recommended_for_post:{post_id}\"]\n):\nyield post\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.PostClient.get_post_comments","title":"<code>get_post_comments(post_id)</code>  <code>async</code>","text":"<p>Get all comments of the specific post by its ID.</p> Source code in <code>sankaku/clients/clients.py</code> <pre><code>async def get_post_comments(self, post_id: int) -&gt; AsyncIterator[mdl.Comment]:\n\"\"\"Get all comments of the specific post by its ID.\"\"\"\nasync for page in Paginator(  # noqa: F405\nconst.LAST_RANGE_ITEM,\nhttp_client=self._http_client,\nurl=const.COMMENTS_URL.format(post_id=post_id),\nmodel=mdl.Comment\n):\nfor comment in page.items:\nyield comment\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.PostClient.get_post","title":"<code>get_post(post_id)</code>  <code>async</code>","text":"<p>Get specific post by its ID.</p> Source code in <code>sankaku/clients/clients.py</code> <pre><code>async def get_post(self, post_id: int) -&gt; mdl.Post:\n\"\"\"Get specific post by its ID.\"\"\"\nresponse = await self._http_client.get(const.POST_URL.format(post_id=post_id))\nif not response.ok:\nraise errors.PageNotFoundError(response.status, post_id=post_id)\nreturn mdl.Post(**response.json)\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.AIClient","title":"<code>sankaku.clients.clients.AIClient</code>","text":"<p>             Bases: <code>BaseClient</code></p> <p>Client for working with Sankaku built-in AI.</p> Source code in <code>sankaku/clients/clients.py</code> <pre><code>class AIClient(BaseClient):\n\"\"\"Client for working with Sankaku built-in AI.\"\"\"\nasync def browse_ai_posts(\nself,\n_start: int,\n_stop: Optional[int] = None,\n_step: Optional[int] = None,\n/\n) -&gt; AsyncIterator[mdl.AIPost]:\n\"\"\"Get a certain range of AI created posts from AI dedicated post pages.\n        Range of posts can be specified in the same way as when using built-in\n        `range()`.\n        Args:\n            _start: Start of the sequence\n            _stop: End of the sequence (except this value itself)\n            _step: Step of the sequence\n        \"\"\"\nitem_range = _process_item_range(_start, _stop, _step)\npage_range = _process_page_range(*item_range[:2], limit=const.BASE_LIMIT)\nslices = _compute_slices(item_range, page_range)\nasync for page in Paginator(  # noqa: F405\n*page_range,\nhttp_client=self._http_client,\nurl=const.AI_POSTS_URL,\nmodel=mdl.AIPost\n):\nfor post in page.items[slices.pop()]:\nyield post\nasync def get_ai_post(self, post_id: int) -&gt; mdl.AIPost:\n\"\"\"Get specific AI post by its ID.\"\"\"\nresponse = await self._http_client.get(\nconst.AI_POST_URL.format(post_id=post_id)\n)\nif not response.ok:\nraise errors.PageNotFoundError(response.status, post_id=post_id)\nreturn mdl.AIPost(**response.json)\nasync def create_ai_post(self):  # TODO: TBA  # noqa: D102\nraise NotImplementedError\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.AIClient.browse_ai_posts","title":"<code>browse_ai_posts(_start, _stop=None, _step=None)</code>  <code>async</code>","text":"<p>Get a certain range of AI created posts from AI dedicated post pages. Range of posts can be specified in the same way as when using built-in <code>range()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>_start</code> <code>int</code> <p>Start of the sequence</p> required <code>_stop</code> <code>Optional[int]</code> <p>End of the sequence (except this value itself)</p> <code>None</code> <code>_step</code> <code>Optional[int]</code> <p>Step of the sequence</p> <code>None</code> Source code in <code>sankaku/clients/clients.py</code> <pre><code>async def browse_ai_posts(\nself,\n_start: int,\n_stop: Optional[int] = None,\n_step: Optional[int] = None,\n/\n) -&gt; AsyncIterator[mdl.AIPost]:\n\"\"\"Get a certain range of AI created posts from AI dedicated post pages.\n    Range of posts can be specified in the same way as when using built-in\n    `range()`.\n    Args:\n        _start: Start of the sequence\n        _stop: End of the sequence (except this value itself)\n        _step: Step of the sequence\n    \"\"\"\nitem_range = _process_item_range(_start, _stop, _step)\npage_range = _process_page_range(*item_range[:2], limit=const.BASE_LIMIT)\nslices = _compute_slices(item_range, page_range)\nasync for page in Paginator(  # noqa: F405\n*page_range,\nhttp_client=self._http_client,\nurl=const.AI_POSTS_URL,\nmodel=mdl.AIPost\n):\nfor post in page.items[slices.pop()]:\nyield post\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.AIClient.get_ai_post","title":"<code>get_ai_post(post_id)</code>  <code>async</code>","text":"<p>Get specific AI post by its ID.</p> Source code in <code>sankaku/clients/clients.py</code> <pre><code>async def get_ai_post(self, post_id: int) -&gt; mdl.AIPost:\n\"\"\"Get specific AI post by its ID.\"\"\"\nresponse = await self._http_client.get(\nconst.AI_POST_URL.format(post_id=post_id)\n)\nif not response.ok:\nraise errors.PageNotFoundError(response.status, post_id=post_id)\nreturn mdl.AIPost(**response.json)\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.TagClient","title":"<code>sankaku.clients.clients.TagClient</code>","text":"<p>             Bases: <code>BaseClient</code></p> <p>Client for tag browsing.</p> Source code in <code>sankaku/clients/clients.py</code> <pre><code>class TagClient(BaseClient):\n\"\"\"Client for tag browsing.\"\"\"\nasync def browse_tags(\nself,\n_start: int,\n_stop: Optional[int] = None,\n_step: Optional[int] = None,\n/,\n*,\ntag_type: Optional[types.TagType] = None,\norder: Optional[types.TagOrder] = None,\nrating: Optional[types.Rating] = None,\nmax_post_count: Optional[int] = None,\nsort_parameter: Optional[types.SortParameter] = None,\nsort_direction: Optional[types.SortDirection] = None\n) -&gt; AsyncIterator[mdl.PageTag]:\n\"\"\"Get a certain range of tags from tag pages.\n        Range of tags can be specified in the same way as when using built-in\n        `range()`.\n        Args:\n            _start: Start of the sequence\n            _stop: End of the sequence (except this value itself)\n            _step: Step of the sequence\n            tag_type: Tag type filter\n            order: Tag order rule\n            rating: Tag rating\n            max_post_count: Upper threshold for number of posts with tags found\n            sort_parameter: Tag sorting parameter\n            sort_direction: Tag sorting direction\n        \"\"\"\nitem_range = _process_item_range(_start, _stop, _step)\npage_range = _process_page_range(*item_range[:2], limit=const.BASE_LIMIT)\nslices = _compute_slices(item_range, page_range)\nasync for page in TagPaginator(  # noqa: F405\n*page_range,\nhttp_client=self._http_client,\ntag_type=tag_type,\norder=order,\nrating=rating,\nmax_post_count=max_post_count,\nsort_parameter=sort_parameter,\nsort_direction=sort_direction\n):\nfor tag in page.items[slices.pop()]:\nyield tag\nasync def get_tag(self, name_or_id: Union[str, int]) -&gt; mdl.WikiTag:\n\"\"\"Get specific tag by its name or ID.\"\"\"\nresponse = await self._http_client.get(\nconst.TAG_WIKI_URL.format(\nref=\"/name\" if isinstance(name_or_id, str) else \"/id\",\nname_or_id=name_or_id\n)\n)\nif not response.ok:\nraise errors.PageNotFoundError(response.status, name_or_id=name_or_id)\nreturn mdl.WikiTag(wiki=response.json[\"wiki\"], **response.json[\"tag\"])\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.TagClient.browse_tags","title":"<code>browse_tags(_start, _stop=None, _step=None, /, *, tag_type=None, order=None, rating=None, max_post_count=None, sort_parameter=None, sort_direction=None)</code>  <code>async</code>","text":"<p>Get a certain range of tags from tag pages. Range of tags can be specified in the same way as when using built-in <code>range()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>_start</code> <code>int</code> <p>Start of the sequence</p> required <code>_stop</code> <code>Optional[int]</code> <p>End of the sequence (except this value itself)</p> <code>None</code> <code>_step</code> <code>Optional[int]</code> <p>Step of the sequence</p> <code>None</code> <code>tag_type</code> <code>Optional[types.TagType]</code> <p>Tag type filter</p> <code>None</code> <code>order</code> <code>Optional[types.TagOrder]</code> <p>Tag order rule</p> <code>None</code> <code>rating</code> <code>Optional[types.Rating]</code> <p>Tag rating</p> <code>None</code> <code>max_post_count</code> <code>Optional[int]</code> <p>Upper threshold for number of posts with tags found</p> <code>None</code> <code>sort_parameter</code> <code>Optional[types.SortParameter]</code> <p>Tag sorting parameter</p> <code>None</code> <code>sort_direction</code> <code>Optional[types.SortDirection]</code> <p>Tag sorting direction</p> <code>None</code> Source code in <code>sankaku/clients/clients.py</code> <pre><code>async def browse_tags(\nself,\n_start: int,\n_stop: Optional[int] = None,\n_step: Optional[int] = None,\n/,\n*,\ntag_type: Optional[types.TagType] = None,\norder: Optional[types.TagOrder] = None,\nrating: Optional[types.Rating] = None,\nmax_post_count: Optional[int] = None,\nsort_parameter: Optional[types.SortParameter] = None,\nsort_direction: Optional[types.SortDirection] = None\n) -&gt; AsyncIterator[mdl.PageTag]:\n\"\"\"Get a certain range of tags from tag pages.\n    Range of tags can be specified in the same way as when using built-in\n    `range()`.\n    Args:\n        _start: Start of the sequence\n        _stop: End of the sequence (except this value itself)\n        _step: Step of the sequence\n        tag_type: Tag type filter\n        order: Tag order rule\n        rating: Tag rating\n        max_post_count: Upper threshold for number of posts with tags found\n        sort_parameter: Tag sorting parameter\n        sort_direction: Tag sorting direction\n    \"\"\"\nitem_range = _process_item_range(_start, _stop, _step)\npage_range = _process_page_range(*item_range[:2], limit=const.BASE_LIMIT)\nslices = _compute_slices(item_range, page_range)\nasync for page in TagPaginator(  # noqa: F405\n*page_range,\nhttp_client=self._http_client,\ntag_type=tag_type,\norder=order,\nrating=rating,\nmax_post_count=max_post_count,\nsort_parameter=sort_parameter,\nsort_direction=sort_direction\n):\nfor tag in page.items[slices.pop()]:\nyield tag\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.TagClient.get_tag","title":"<code>get_tag(name_or_id)</code>  <code>async</code>","text":"<p>Get specific tag by its name or ID.</p> Source code in <code>sankaku/clients/clients.py</code> <pre><code>async def get_tag(self, name_or_id: Union[str, int]) -&gt; mdl.WikiTag:\n\"\"\"Get specific tag by its name or ID.\"\"\"\nresponse = await self._http_client.get(\nconst.TAG_WIKI_URL.format(\nref=\"/name\" if isinstance(name_or_id, str) else \"/id\",\nname_or_id=name_or_id\n)\n)\nif not response.ok:\nraise errors.PageNotFoundError(response.status, name_or_id=name_or_id)\nreturn mdl.WikiTag(wiki=response.json[\"wiki\"], **response.json[\"tag\"])\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.BookClient","title":"<code>sankaku.clients.clients.BookClient</code>","text":"<p>             Bases: <code>BaseClient</code></p> <p>Client for book (pool) browsing.</p> Source code in <code>sankaku/clients/clients.py</code> <pre><code>class BookClient(BaseClient):\n\"\"\"Client for book (pool) browsing.\"\"\"\nasync def browse_books(\nself,\n_start: int,\n_stop: Optional[int] = None,\n_step: Optional[int] = None,\n/,\n*,\norder: Optional[types.BookOrder] = None,\nrating: Optional[types.Rating] = None,\nrecommended_for: Optional[str] = None,\nfavorited_by: Optional[str] = None,\ntags: Optional[List[str]] = None,\nadded_by: Optional[List[str]] = None,\nvoted: Optional[str] = None,\n) -&gt; AsyncIterator[mdl.PageBook]:\n\"\"\"Get a certain range of books (pools) from book (pool) pages.\n        Range of books can be specified in the same way as when using built-in\n        `range()`.\n        Args:\n            _start: Start of the sequence\n            _stop: End of the sequence (except this value itself)\n            _step: Step of the sequence\n            order: Book order rule\n            rating: Books rating\n            recommended_for: Books recommended for specified user\n            favorited_by: Books favorited by specified user\n            tags: Tags available for search\n            added_by: Books uploaded by specified users\n            voted: Books voted by specified user\n        \"\"\"\nitem_range = _process_item_range(_start, _stop, _step)\npage_range = _process_page_range(*item_range[:2], limit=const.BASE_LIMIT)\nslices = _compute_slices(item_range, page_range)\nasync for page in BookPaginator(  # noqa: F405\n*page_range,\nhttp_client=self._http_client,\norder=order,\nrating=rating,\nrecommended_for=recommended_for,\nfavorited_by=favorited_by,\ntags=tags,\nadded_by=added_by,\nvoted=voted\n):\nfor book in page.items[slices.pop()]:\nyield book\nasync def get_favorited_books(\nself,\n_start: int,\n_stop: Optional[int] = None,\n_step: Optional[int] = None,\n/\n) -&gt; AsyncIterator[mdl.PageBook]:\n\"\"\"Shorthand way to get a certain range of favorited books for\n        currently logged-in user.\n        Range of books can be specified in the same way as when using built-in\n        `range()`.\n        Args:\n            _start: Start of the sequence\n            _stop: End of the sequence (except this value itself)\n            _step: Step of the sequence\n        \"\"\"\nif self._profile is None:\nraise errors.LoginRequirementError\nasync for book in self.browse_books(\n_start, _stop, _step,\nfavorited_by=self._profile.name\n):\nyield book\nasync def get_recommended_books(\nself,\n_start: int,\n_stop: Optional[int] = None,\n_step: Optional[int] = None,\n/\n) -&gt; AsyncIterator[mdl.PageBook]:\n\"\"\"Shorthand way to get a certain range of recommended books for\n        currently logged-in user.\n        Range of books can be specified in the same way as when using built-in\n        `range()`.\n        Args:\n            _start: Start of the sequence\n            _stop: End of the sequence (except this value itself)\n            _step: Step of the sequence\n        \"\"\"\nif self._profile is None:\nraise errors.LoginRequirementError\nasync for book in self.browse_books(\n_start, _stop, _step,\nrecommended_for=self._profile.name\n):\nyield book\nasync def get_recently_read_books(\nself,\n_start: int,\n_stop: Optional[int] = None,\n_step: Optional[int] = None,\n/\n) -&gt; AsyncIterator[mdl.PageBook]:\n\"\"\"Get a certain range of recently read/opened books of currently\n        logged-in user.\n        Range of books can be specified in the same way as when using built-in\n        `range()`.\n        Args:\n            _start: Start of the sequence\n            _stop: End of the sequence (except this value itself)\n            _step: Step of the sequence\n        \"\"\"\nif self._profile is None:\nraise errors.LoginRequirementError\nasync for book in self.browse_books(\n_start, _stop, _step,\ntags=[f\"read:@{self._profile.id}@\"]\n):\nyield book\nasync def get_related_books(\nself,\n_start: int,\n_stop: Optional[int] = None,\n_step: Optional[int] = None,\n/,\n*,\npost_id: int\n) -&gt; AsyncIterator[mdl.PageBook]:\n\"\"\"Get a certain range of books related to specific post.\n        Range of books can be specified in the same way as when using built-in\n        `range()`.\n        Args:\n            _start: Start of the sequence\n            _stop: End of the sequence (except this value itself)\n            _step: Step of the sequence\n            post_id: ID of the post of interest\n        \"\"\"\nitem_range = _process_item_range(_start, _stop, _step)\npage_range = _process_page_range(*item_range[:2], limit=const.BASE_LIMIT)\nslices = _compute_slices(item_range, page_range)\nasync for page in BookPaginator(  # noqa: F405\n*page_range,\nhttp_client=self._http_client,\nurl=const.RELATED_BOOKS_URL.format(post_id=post_id)\n):\nfor book in page.items[slices.pop()]:\nyield book\nasync def get_book(self, book_id: int) -&gt; mdl.Book:\n\"\"\"Get specific book by its ID.\"\"\"\nresponse = await self._http_client.get(const.BOOK_URL.format(book_id=book_id))\nif not response.ok:\nraise errors.PageNotFoundError(response.status, book_id=book_id)\nreturn mdl.Book(**response.json)\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.BookClient.browse_books","title":"<code>browse_books(_start, _stop=None, _step=None, /, *, order=None, rating=None, recommended_for=None, favorited_by=None, tags=None, added_by=None, voted=None)</code>  <code>async</code>","text":"<p>Get a certain range of books (pools) from book (pool) pages. Range of books can be specified in the same way as when using built-in <code>range()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>_start</code> <code>int</code> <p>Start of the sequence</p> required <code>_stop</code> <code>Optional[int]</code> <p>End of the sequence (except this value itself)</p> <code>None</code> <code>_step</code> <code>Optional[int]</code> <p>Step of the sequence</p> <code>None</code> <code>order</code> <code>Optional[types.BookOrder]</code> <p>Book order rule</p> <code>None</code> <code>rating</code> <code>Optional[types.Rating]</code> <p>Books rating</p> <code>None</code> <code>recommended_for</code> <code>Optional[str]</code> <p>Books recommended for specified user</p> <code>None</code> <code>favorited_by</code> <code>Optional[str]</code> <p>Books favorited by specified user</p> <code>None</code> <code>tags</code> <code>Optional[List[str]]</code> <p>Tags available for search</p> <code>None</code> <code>added_by</code> <code>Optional[List[str]]</code> <p>Books uploaded by specified users</p> <code>None</code> <code>voted</code> <code>Optional[str]</code> <p>Books voted by specified user</p> <code>None</code> Source code in <code>sankaku/clients/clients.py</code> <pre><code>async def browse_books(\nself,\n_start: int,\n_stop: Optional[int] = None,\n_step: Optional[int] = None,\n/,\n*,\norder: Optional[types.BookOrder] = None,\nrating: Optional[types.Rating] = None,\nrecommended_for: Optional[str] = None,\nfavorited_by: Optional[str] = None,\ntags: Optional[List[str]] = None,\nadded_by: Optional[List[str]] = None,\nvoted: Optional[str] = None,\n) -&gt; AsyncIterator[mdl.PageBook]:\n\"\"\"Get a certain range of books (pools) from book (pool) pages.\n    Range of books can be specified in the same way as when using built-in\n    `range()`.\n    Args:\n        _start: Start of the sequence\n        _stop: End of the sequence (except this value itself)\n        _step: Step of the sequence\n        order: Book order rule\n        rating: Books rating\n        recommended_for: Books recommended for specified user\n        favorited_by: Books favorited by specified user\n        tags: Tags available for search\n        added_by: Books uploaded by specified users\n        voted: Books voted by specified user\n    \"\"\"\nitem_range = _process_item_range(_start, _stop, _step)\npage_range = _process_page_range(*item_range[:2], limit=const.BASE_LIMIT)\nslices = _compute_slices(item_range, page_range)\nasync for page in BookPaginator(  # noqa: F405\n*page_range,\nhttp_client=self._http_client,\norder=order,\nrating=rating,\nrecommended_for=recommended_for,\nfavorited_by=favorited_by,\ntags=tags,\nadded_by=added_by,\nvoted=voted\n):\nfor book in page.items[slices.pop()]:\nyield book\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.BookClient.get_favorited_books","title":"<code>get_favorited_books(_start, _stop=None, _step=None)</code>  <code>async</code>","text":"<p>Shorthand way to get a certain range of favorited books for currently logged-in user. Range of books can be specified in the same way as when using built-in <code>range()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>_start</code> <code>int</code> <p>Start of the sequence</p> required <code>_stop</code> <code>Optional[int]</code> <p>End of the sequence (except this value itself)</p> <code>None</code> <code>_step</code> <code>Optional[int]</code> <p>Step of the sequence</p> <code>None</code> Source code in <code>sankaku/clients/clients.py</code> <pre><code>async def get_favorited_books(\nself,\n_start: int,\n_stop: Optional[int] = None,\n_step: Optional[int] = None,\n/\n) -&gt; AsyncIterator[mdl.PageBook]:\n\"\"\"Shorthand way to get a certain range of favorited books for\n    currently logged-in user.\n    Range of books can be specified in the same way as when using built-in\n    `range()`.\n    Args:\n        _start: Start of the sequence\n        _stop: End of the sequence (except this value itself)\n        _step: Step of the sequence\n    \"\"\"\nif self._profile is None:\nraise errors.LoginRequirementError\nasync for book in self.browse_books(\n_start, _stop, _step,\nfavorited_by=self._profile.name\n):\nyield book\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.BookClient.get_recommended_books","title":"<code>get_recommended_books(_start, _stop=None, _step=None)</code>  <code>async</code>","text":"<p>Shorthand way to get a certain range of recommended books for currently logged-in user. Range of books can be specified in the same way as when using built-in <code>range()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>_start</code> <code>int</code> <p>Start of the sequence</p> required <code>_stop</code> <code>Optional[int]</code> <p>End of the sequence (except this value itself)</p> <code>None</code> <code>_step</code> <code>Optional[int]</code> <p>Step of the sequence</p> <code>None</code> Source code in <code>sankaku/clients/clients.py</code> <pre><code>async def get_recommended_books(\nself,\n_start: int,\n_stop: Optional[int] = None,\n_step: Optional[int] = None,\n/\n) -&gt; AsyncIterator[mdl.PageBook]:\n\"\"\"Shorthand way to get a certain range of recommended books for\n    currently logged-in user.\n    Range of books can be specified in the same way as when using built-in\n    `range()`.\n    Args:\n        _start: Start of the sequence\n        _stop: End of the sequence (except this value itself)\n        _step: Step of the sequence\n    \"\"\"\nif self._profile is None:\nraise errors.LoginRequirementError\nasync for book in self.browse_books(\n_start, _stop, _step,\nrecommended_for=self._profile.name\n):\nyield book\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.BookClient.get_recently_read_books","title":"<code>get_recently_read_books(_start, _stop=None, _step=None)</code>  <code>async</code>","text":"<p>Get a certain range of recently read/opened books of currently logged-in user. Range of books can be specified in the same way as when using built-in <code>range()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>_start</code> <code>int</code> <p>Start of the sequence</p> required <code>_stop</code> <code>Optional[int]</code> <p>End of the sequence (except this value itself)</p> <code>None</code> <code>_step</code> <code>Optional[int]</code> <p>Step of the sequence</p> <code>None</code> Source code in <code>sankaku/clients/clients.py</code> <pre><code>async def get_recently_read_books(\nself,\n_start: int,\n_stop: Optional[int] = None,\n_step: Optional[int] = None,\n/\n) -&gt; AsyncIterator[mdl.PageBook]:\n\"\"\"Get a certain range of recently read/opened books of currently\n    logged-in user.\n    Range of books can be specified in the same way as when using built-in\n    `range()`.\n    Args:\n        _start: Start of the sequence\n        _stop: End of the sequence (except this value itself)\n        _step: Step of the sequence\n    \"\"\"\nif self._profile is None:\nraise errors.LoginRequirementError\nasync for book in self.browse_books(\n_start, _stop, _step,\ntags=[f\"read:@{self._profile.id}@\"]\n):\nyield book\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.BookClient.get_related_books","title":"<code>get_related_books(_start, _stop=None, _step=None, /, *, post_id)</code>  <code>async</code>","text":"<p>Get a certain range of books related to specific post. Range of books can be specified in the same way as when using built-in <code>range()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>_start</code> <code>int</code> <p>Start of the sequence</p> required <code>_stop</code> <code>Optional[int]</code> <p>End of the sequence (except this value itself)</p> <code>None</code> <code>_step</code> <code>Optional[int]</code> <p>Step of the sequence</p> <code>None</code> <code>post_id</code> <code>int</code> <p>ID of the post of interest</p> required Source code in <code>sankaku/clients/clients.py</code> <pre><code>async def get_related_books(\nself,\n_start: int,\n_stop: Optional[int] = None,\n_step: Optional[int] = None,\n/,\n*,\npost_id: int\n) -&gt; AsyncIterator[mdl.PageBook]:\n\"\"\"Get a certain range of books related to specific post.\n    Range of books can be specified in the same way as when using built-in\n    `range()`.\n    Args:\n        _start: Start of the sequence\n        _stop: End of the sequence (except this value itself)\n        _step: Step of the sequence\n        post_id: ID of the post of interest\n    \"\"\"\nitem_range = _process_item_range(_start, _stop, _step)\npage_range = _process_page_range(*item_range[:2], limit=const.BASE_LIMIT)\nslices = _compute_slices(item_range, page_range)\nasync for page in BookPaginator(  # noqa: F405\n*page_range,\nhttp_client=self._http_client,\nurl=const.RELATED_BOOKS_URL.format(post_id=post_id)\n):\nfor book in page.items[slices.pop()]:\nyield book\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.BookClient.get_book","title":"<code>get_book(book_id)</code>  <code>async</code>","text":"<p>Get specific book by its ID.</p> Source code in <code>sankaku/clients/clients.py</code> <pre><code>async def get_book(self, book_id: int) -&gt; mdl.Book:\n\"\"\"Get specific book by its ID.\"\"\"\nresponse = await self._http_client.get(const.BOOK_URL.format(book_id=book_id))\nif not response.ok:\nraise errors.PageNotFoundError(response.status, book_id=book_id)\nreturn mdl.Book(**response.json)\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.UserClient","title":"<code>sankaku.clients.clients.UserClient</code>","text":"<p>             Bases: <code>BaseClient</code></p> <p>Client for browsing users.</p> Source code in <code>sankaku/clients/clients.py</code> <pre><code>class UserClient(BaseClient):\n\"\"\"Client for browsing users.\"\"\"\nasync def browse_users(\nself,\n_start: int,\n_stop: Optional[int] = None,\n_step: Optional[int] = None,\n/,\n*,\norder: Optional[types.UserOrder] = None,\nlevel: Optional[types.UserLevel] = None,\n) -&gt; AsyncIterator[mdl.User]:\n\"\"\"Get a certain range of user profiles from user pages.\n        Range of user profiles can be specified in the same way as when using\n        built-in `range()`.\n        Args:\n            _start: Start of the sequence\n            _stop: End of the sequence (except this value itself)\n            _step: Step of the sequence\n            order: User order rule\n            level: User level type\n        \"\"\"\nitem_range = _process_item_range(_start, _stop, _step)\npage_range = _process_page_range(*item_range[:2], limit=const.BASE_LIMIT)\nslices = _compute_slices(item_range, page_range)\nasync for page in UserPaginator(  # noqa: F405\n*page_range,\nhttp_client=self._http_client,\norder=order,\nlevel=level\n):\nfor user in page.items[slices.pop()]:\nyield user\nasync def get_user(self, name_or_id: Union[str, int]) -&gt; mdl.User:\n\"\"\"Get specific user by its name or ID.\"\"\"\nresponse = await self._http_client.get(\nconst.USER_URL.format(\nref=\"/name\" if isinstance(name_or_id, str) else \"\",\nname_or_id=name_or_id\n)\n)\nif not response.ok:\nraise errors.PageNotFoundError(response.status, name_or_id=name_or_id)\nreturn mdl.User(**response.json)\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.UserClient.browse_users","title":"<code>browse_users(_start, _stop=None, _step=None, /, *, order=None, level=None)</code>  <code>async</code>","text":"<p>Get a certain range of user profiles from user pages. Range of user profiles can be specified in the same way as when using built-in <code>range()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>_start</code> <code>int</code> <p>Start of the sequence</p> required <code>_stop</code> <code>Optional[int]</code> <p>End of the sequence (except this value itself)</p> <code>None</code> <code>_step</code> <code>Optional[int]</code> <p>Step of the sequence</p> <code>None</code> <code>order</code> <code>Optional[types.UserOrder]</code> <p>User order rule</p> <code>None</code> <code>level</code> <code>Optional[types.UserLevel]</code> <p>User level type</p> <code>None</code> Source code in <code>sankaku/clients/clients.py</code> <pre><code>async def browse_users(\nself,\n_start: int,\n_stop: Optional[int] = None,\n_step: Optional[int] = None,\n/,\n*,\norder: Optional[types.UserOrder] = None,\nlevel: Optional[types.UserLevel] = None,\n) -&gt; AsyncIterator[mdl.User]:\n\"\"\"Get a certain range of user profiles from user pages.\n    Range of user profiles can be specified in the same way as when using\n    built-in `range()`.\n    Args:\n        _start: Start of the sequence\n        _stop: End of the sequence (except this value itself)\n        _step: Step of the sequence\n        order: User order rule\n        level: User level type\n    \"\"\"\nitem_range = _process_item_range(_start, _stop, _step)\npage_range = _process_page_range(*item_range[:2], limit=const.BASE_LIMIT)\nslices = _compute_slices(item_range, page_range)\nasync for page in UserPaginator(  # noqa: F405\n*page_range,\nhttp_client=self._http_client,\norder=order,\nlevel=level\n):\nfor user in page.items[slices.pop()]:\nyield user\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.UserClient.get_user","title":"<code>get_user(name_or_id)</code>  <code>async</code>","text":"<p>Get specific user by its name or ID.</p> Source code in <code>sankaku/clients/clients.py</code> <pre><code>async def get_user(self, name_or_id: Union[str, int]) -&gt; mdl.User:\n\"\"\"Get specific user by its name or ID.\"\"\"\nresponse = await self._http_client.get(\nconst.USER_URL.format(\nref=\"/name\" if isinstance(name_or_id, str) else \"\",\nname_or_id=name_or_id\n)\n)\nif not response.ok:\nraise errors.PageNotFoundError(response.status, name_or_id=name_or_id)\nreturn mdl.User(**response.json)\n</code></pre>"},{"location":"api/clients/http_client/","title":"Documentation for <code>http_client.py</code>","text":""},{"location":"api/clients/http_client/#sankaku.clients.http_client.HttpClient","title":"<code>sankaku.clients.http_client.HttpClient</code>","text":"<p>             Bases: <code>ABCHttpClient</code></p> Source code in <code>sankaku/clients/http_client.py</code> <pre><code>class HttpClient(ABCHttpClient):\ndef __init__(self) -&gt; None:\n\"\"\"HTTP client for API requests that instances use a single session.\"\"\"\nself.headers: Dict[str, str] = const.HEADERS.copy()\nsocks_connector = _get_socks_connector()\nif socks_connector is not None:\n# use socks connector\nkwargs = {\"connector\": socks_connector}\nelse:\n# aiohttp will read HTTP_PROXY and HTTPS_PROXY from env\nkwargs = {\"trust_env\": True}\nself._client_session: ClientSession = ClientSession(**kwargs)  # type: ignore\nretry_options = ExponentialRetry(attempts=BASE_RETRIES)\nself.session: RetryClient = RetryClient(\nraise_for_status=False,\nretry_options=retry_options,\nclient_session=self._client_session\n)\ndef __del__(self) -&gt; None:\nif not self._client_session.closed and self._client_session.connector is not None:  # noqa: E501\nself._client_session.connector.close()\nasync def close(self) -&gt; None:\n\"\"\"There is no need to close client with single session.\"\"\"\nasync def request(self, method: str, url: str, **kwargs) -&gt; ClientResponse:\n\"\"\"Make request to specified url.\"\"\"\nif kwargs.get(\"headers\") is None:\nkwargs[\"headers\"] = self.headers\nresponse = await self.session.request(method, url, **kwargs)\nlogger.debug(f\"Sent {method} request to {response.url}\")\nif response.content_type != \"application/json\":\nraise errors.SankakuServerError(\nresponse.status, \"Invalid response content type\",\ncontent_type=response.content_type\n)\nclient_response = ClientResponse(\nresponse.status,\nresponse.ok,\nawait response.json(encoding=\"utf-8\"),\n)\nresponse.close()\nlogger.debug(\nf\"Request {method} returned response with status \"\nf\"[{client_response.status}]: {client_response.json}\",\n)\nreturn client_response\nasync def get(self, url: str, **kwargs) -&gt; ClientResponse:\n\"\"\"Send GET request to specified url.\"\"\"\nreturn await self.request(\"GET\", url, **kwargs)\nasync def post(self, url: str, **kwargs) -&gt; ClientResponse:\n\"\"\"Send POST request to specified url.\"\"\"\nreturn await self.request(\"POST\", url, **kwargs)\n</code></pre>"},{"location":"api/clients/http_client/#sankaku.clients.http_client.HttpClient.close","title":"<code>close()</code>  <code>async</code>","text":"<p>There is no need to close client with single session.</p> Source code in <code>sankaku/clients/http_client.py</code> <pre><code>async def close(self) -&gt; None:\n\"\"\"There is no need to close client with single session.\"\"\"\n</code></pre>"},{"location":"api/clients/http_client/#sankaku.clients.http_client.HttpClient.request","title":"<code>request(method, url, **kwargs)</code>  <code>async</code>","text":"<p>Make request to specified url.</p> Source code in <code>sankaku/clients/http_client.py</code> <pre><code>async def request(self, method: str, url: str, **kwargs) -&gt; ClientResponse:\n\"\"\"Make request to specified url.\"\"\"\nif kwargs.get(\"headers\") is None:\nkwargs[\"headers\"] = self.headers\nresponse = await self.session.request(method, url, **kwargs)\nlogger.debug(f\"Sent {method} request to {response.url}\")\nif response.content_type != \"application/json\":\nraise errors.SankakuServerError(\nresponse.status, \"Invalid response content type\",\ncontent_type=response.content_type\n)\nclient_response = ClientResponse(\nresponse.status,\nresponse.ok,\nawait response.json(encoding=\"utf-8\"),\n)\nresponse.close()\nlogger.debug(\nf\"Request {method} returned response with status \"\nf\"[{client_response.status}]: {client_response.json}\",\n)\nreturn client_response\n</code></pre>"},{"location":"api/clients/http_client/#sankaku.clients.http_client.HttpClient.get","title":"<code>get(url, **kwargs)</code>  <code>async</code>","text":"<p>Send GET request to specified url.</p> Source code in <code>sankaku/clients/http_client.py</code> <pre><code>async def get(self, url: str, **kwargs) -&gt; ClientResponse:\n\"\"\"Send GET request to specified url.\"\"\"\nreturn await self.request(\"GET\", url, **kwargs)\n</code></pre>"},{"location":"api/clients/http_client/#sankaku.clients.http_client.HttpClient.post","title":"<code>post(url, **kwargs)</code>  <code>async</code>","text":"<p>Send POST request to specified url.</p> Source code in <code>sankaku/clients/http_client.py</code> <pre><code>async def post(self, url: str, **kwargs) -&gt; ClientResponse:\n\"\"\"Send POST request to specified url.\"\"\"\nreturn await self.request(\"POST\", url, **kwargs)\n</code></pre>"},{"location":"api/models/base/","title":"Documentation for <code>base.py</code>","text":""},{"location":"api/models/base/#sankaku.models.base.SankakuResponseModel","title":"<code>sankaku.models.base.SankakuResponseModel</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Base model for sankaku JSON responses.</p> Source code in <code>sankaku/models/base.py</code> <pre><code>class SankakuResponseModel(BaseModel, extra=\"forbid\"):\n\"\"\"Base model for sankaku JSON responses.\"\"\"\n</code></pre>"},{"location":"api/models/books/","title":"Documentation for <code>books.py</code>","text":""},{"location":"api/models/books/#sankaku.models.books.BookState","title":"<code>sankaku.models.books.BookState</code>","text":"<p>             Bases: <code>SankakuResponseModel</code></p>"},{"location":"api/models/books/#sankaku.models.books.BookState.current_page","title":"<code>current_page: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.BookState.sequence","title":"<code>sequence: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.BookState.post_id","title":"<code>post_id: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.BookState.series_id","title":"<code>series_id: Optional[int]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.BookState.created_at","title":"<code>created_at: datetime</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.BookState.updated_at","title":"<code>updated_at: datetime</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.BookState.percent","title":"<code>percent: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook","title":"<code>sankaku.models.books.PageBook</code>","text":"<p>             Bases: <code>SankakuResponseModel</code></p> <p>Model that describes books on book pages.</p>"},{"location":"api/models/books/#sankaku.models.books.PageBook.id","title":"<code>id: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.name_en","title":"<code>name_en: Optional[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.name_ja","title":"<code>name_ja: Optional[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.description","title":"<code>description: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.description_en","title":"<code>description_en: Optional[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.description_ja","title":"<code>description_ja: Optional[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.created_at","title":"<code>created_at: datetime</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.updated_at","title":"<code>updated_at: datetime</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.author","title":"<code>author: Optional[Author]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.is_public","title":"<code>is_public: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.is_active","title":"<code>is_active: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.is_flagged","title":"<code>is_flagged: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.post_count","title":"<code>post_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.pages_count","title":"<code>pages_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.visible_post_count","title":"<code>visible_post_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.is_intact","title":"<code>is_intact: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.rating","title":"<code>rating: Optional[types.Rating]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.parent_id","title":"<code>parent_id: Optional[int]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.has_children","title":"<code>has_children: Optional[bool]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.is_rating_locked","title":"<code>is_rating_locked: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.fav_count","title":"<code>fav_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.vote_count","title":"<code>vote_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.total_score","title":"<code>total_score: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.comment_count","title":"<code>comment_count: Optional[int]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.tags","title":"<code>tags: List[PostTag]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.post_tags","title":"<code>post_tags: List[PostTag]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.artist_tags","title":"<code>artist_tags: List[PostTag]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.genre_tags","title":"<code>genre_tags: List[PostTag]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.is_favorited","title":"<code>is_favorited: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.user_vote","title":"<code>user_vote: Optional[int]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.posts","title":"<code>posts: List[Optional[Post]]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.file_url","title":"<code>file_url: Optional[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.sample_url","title":"<code>sample_url: Optional[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.preview_url","title":"<code>preview_url: Optional[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.cover_post","title":"<code>cover_post: Optional[Post]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.reading","title":"<code>reading: Optional[BookState]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.is_premium","title":"<code>is_premium: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.is_pending","title":"<code>is_pending: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.is_raw","title":"<code>is_raw: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.is_trial","title":"<code>is_trial: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.redirect_to_signup","title":"<code>redirect_to_signup: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.locale","title":"<code>locale: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.is_deleted","title":"<code>is_deleted: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.cover_post_id","title":"<code>cover_post_id: Optional[int]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.name","title":"<code>name: Optional[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.parent_pool","title":"<code>parent_pool: Optional[PageBook]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.Book","title":"<code>sankaku.models.books.Book</code>","text":"<p>             Bases: <code>PageBook</code></p> <p>Model that describes specific book.</p>"},{"location":"api/models/books/#sankaku.models.books.Book.child_pools","title":"<code>child_pools: Optional[List[PageBook]]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.Book.flagged_by_user","title":"<code>flagged_by_user: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.Book.prem_post_count","title":"<code>prem_post_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/http/","title":"Documentation for <code>http.py</code>","text":""},{"location":"api/models/http/#sankaku.models.http.ClientResponse","title":"<code>sankaku.models.http.ClientResponse</code>  <code>dataclass</code>","text":"<p>Dataclass that preserves information from aiohttp ClientResponse.</p>"},{"location":"api/models/http/#sankaku.models.http.ClientResponse.status","title":"<code>status: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/http/#sankaku.models.http.ClientResponse.json","title":"<code>json: Any</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/http/#sankaku.models.http.ClientResponse.ok","title":"<code>ok: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/pages/","title":"Documentation for <code>pages.py</code>","text":""},{"location":"api/models/pages/#sankaku.models.pages.Page","title":"<code>sankaku.models.pages.Page</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Generic[_T]</code></p> <p>Model that describes page containing content with specific type.</p>"},{"location":"api/models/pages/#sankaku.models.pages.Page.number","title":"<code>number: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/pages/#sankaku.models.pages.Page.items","title":"<code>items: List[_T]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/","title":"Documentation for <code>posts.py</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.GenerationDirectivesAspectRatio","title":"<code>sankaku.models.posts.GenerationDirectivesAspectRatio</code>","text":"<p>             Bases: <code>SankakuResponseModel</code></p>"},{"location":"api/models/posts/#sankaku.models.posts.GenerationDirectivesAspectRatio.type","title":"<code>type: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.GenerationDirectivesAspectRatio.width","title":"<code>width: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.GenerationDirectivesAspectRatio.height","title":"<code>height: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.GenerationDirectivesRating","title":"<code>sankaku.models.posts.GenerationDirectivesRating</code>","text":"<p>             Bases: <code>SankakuResponseModel</code></p>"},{"location":"api/models/posts/#sankaku.models.posts.GenerationDirectivesRating.value","title":"<code>value: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.GenerationDirectivesRating.default","title":"<code>default: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.GenerationDirectives","title":"<code>sankaku.models.posts.GenerationDirectives</code>","text":"<p>             Bases: <code>SankakuResponseModel</code></p>"},{"location":"api/models/posts/#sankaku.models.posts.GenerationDirectives.tags","title":"<code>tags: List[GenerationDirectivesTag]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.GenerationDirectives.aspect_ratio","title":"<code>aspect_ratio: Optional[GenerationDirectivesAspectRatio] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.GenerationDirectives.rating","title":"<code>rating: Optional[GenerationDirectivesRating] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.GenerationDirectives.negative_prompt","title":"<code>negative_prompt: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.GenerationDirectives.natural_input","title":"<code>natural_input: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.GenerationDirectives.denoising_strength","title":"<code>denoising_strength: Optional[int] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.AIGenerationDirectives","title":"<code>sankaku.models.posts.AIGenerationDirectives</code>","text":"<p>             Bases: <code>SankakuResponseModel</code></p> <p>Model that describes additional fields for AI-generated posts.</p>"},{"location":"api/models/posts/#sankaku.models.posts.AIGenerationDirectives.width","title":"<code>width: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.AIGenerationDirectives.height","title":"<code>height: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.AIGenerationDirectives.prompt","title":"<code>prompt: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.AIGenerationDirectives.batch_size","title":"<code>batch_size: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.AIGenerationDirectives.batch_count","title":"<code>batch_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.AIGenerationDirectives.sampling_steps","title":"<code>sampling_steps: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.AIGenerationDirectives.negative_prompt","title":"<code>negative_prompt: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.AIGenerationDirectives.version","title":"<code>version: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.BasePost","title":"<code>sankaku.models.posts.BasePost</code>","text":"<p>             Bases: <code>SankakuResponseModel</code></p> <p>Model that contains minimum amount of information that all posts have.</p>"},{"location":"api/models/posts/#sankaku.models.posts.BasePost.id","title":"<code>id: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.BasePost.created_at","title":"<code>created_at: datetime</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.BasePost.rating","title":"<code>rating: types.Rating</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.BasePost.status","title":"<code>status: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.BasePost.author","title":"<code>author: Author</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.BasePost.file_url","title":"<code>file_url: Optional[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.BasePost.preview_url","title":"<code>preview_url: Optional[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.BasePost.width","title":"<code>width: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.BasePost.height","title":"<code>height: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.BasePost.file_size","title":"<code>file_size: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.BasePost.file_type","title":"<code>file_type: Optional[types.FileType] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.BasePost.extension","title":"<code>extension: Optional[str] = Field(alias='file_type', default=None)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.BasePost.md5","title":"<code>md5: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.BasePost.tags","title":"<code>tags: List[PostTag]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Comment","title":"<code>sankaku.models.posts.Comment</code>","text":"<p>             Bases: <code>SankakuResponseModel</code></p> <p>Model that describes comments related to posts if they are exist.</p>"},{"location":"api/models/posts/#sankaku.models.posts.Comment.id","title":"<code>id: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Comment.created_at","title":"<code>created_at: datetime</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Comment.post_id","title":"<code>post_id: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Comment.author","title":"<code>author: Author</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Comment.body","title":"<code>body: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Comment.score","title":"<code>score: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Comment.parent_id","title":"<code>parent_id: Optional[int]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Comment.children","title":"<code>children: List[Comment]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Comment.deleted","title":"<code>deleted: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Comment.deleted_by","title":"<code>deleted_by: dict</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Comment.updated_at","title":"<code>updated_at: Optional[datetime]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Comment.can_reply","title":"<code>can_reply: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Comment.reason","title":"<code>reason: None</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post","title":"<code>sankaku.models.posts.Post</code>","text":"<p>             Bases: <code>BasePost</code></p> <p>Model that describes posts.</p>"},{"location":"api/models/posts/#sankaku.models.posts.Post.sample_url","title":"<code>sample_url: Optional[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.sample_width","title":"<code>sample_width: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.sample_height","title":"<code>sample_height: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.preview_width","title":"<code>preview_width: Optional[int]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.preview_height","title":"<code>preview_height: Optional[int]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.has_children","title":"<code>has_children: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.has_comments","title":"<code>has_comments: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.has_notes","title":"<code>has_notes: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.is_favorited","title":"<code>is_favorited: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.user_vote","title":"<code>user_vote: Optional[int]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.parent_id","title":"<code>parent_id: Optional[int]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.change","title":"<code>change: Optional[int]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.fav_count","title":"<code>fav_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.recommended_posts","title":"<code>recommended_posts: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.recommended_score","title":"<code>recommended_score: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.vote_count","title":"<code>vote_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.total_score","title":"<code>total_score: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.comment_count","title":"<code>comment_count: Optional[int]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.source","title":"<code>source: Optional[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.in_visible_pool","title":"<code>in_visible_pool: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.is_premium","title":"<code>is_premium: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.is_rating_locked","title":"<code>is_rating_locked: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.is_note_locked","title":"<code>is_note_locked: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.is_status_locked","title":"<code>is_status_locked: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.redirect_to_signup","title":"<code>redirect_to_signup: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.sequence","title":"<code>sequence: Optional[int] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.video_duration","title":"<code>video_duration: Optional[float]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.generation_directives","title":"<code>generation_directives: Optional[GenerationDirectives]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.AIPost","title":"<code>sankaku.models.posts.AIPost</code>","text":"<p>             Bases: <code>BasePost</code></p> <p>Model that describes AI-generated posts.</p> <p>There is possibility that AI posts have the same fields as common posts, but premium account is needed to check it properly. So this model is actual for non-premium accounts.</p>"},{"location":"api/models/posts/#sankaku.models.posts.AIPost.updated_at","title":"<code>updated_at: Optional[datetime]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.AIPost.post_associated_id","title":"<code>post_associated_id: Optional[int]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.AIPost.generation_directives","title":"<code>generation_directives: Optional[AIGenerationDirectives]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/","title":"Documentation for <code>tags.py</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.BaseTag","title":"<code>sankaku.models.tags.BaseTag</code>","text":"<p>             Bases: <code>SankakuResponseModel</code></p> <p>Model that contains minimum amount of information that all tags have.</p>"},{"location":"api/models/tags/#sankaku.models.tags.BaseTag.id","title":"<code>id: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.BaseTag.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.BaseTag.name_en","title":"<code>name_en: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.BaseTag.name_ja","title":"<code>name_ja: Optional[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.BaseTag.type","title":"<code>type: types.TagType</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.BaseTag.post_count","title":"<code>post_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.BaseTag.pool_count","title":"<code>pool_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.BaseTag.series_count","title":"<code>series_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.BaseTag.rating","title":"<code>rating: Optional[types.Rating]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.GenerationDirectivesTag","title":"<code>sankaku.models.tags.GenerationDirectivesTag</code>","text":"<p>             Bases: <code>BaseTag</code></p>"},{"location":"api/models/tags/#sankaku.models.tags.GenerationDirectivesTag.count","title":"<code>count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.GenerationDirectivesTag.tag_name","title":"<code>tag_name: str = Field(alias='tagName')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.GenerationDirectivesTag.translations","title":"<code>translations: List[str] = Field(alias='tag_translations')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.TagMixin","title":"<code>sankaku.models.tags.TagMixin</code>","text":"<p>             Bases: <code>SankakuResponseModel</code></p> <p>Additional data that certain tags have.</p>"},{"location":"api/models/tags/#sankaku.models.tags.TagMixin.count","title":"<code>count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.TagMixin.tag_name","title":"<code>tag_name: str = Field(alias='tagName')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.TagMixin.total_post_count","title":"<code>total_post_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.TagMixin.total_pool_count","title":"<code>total_pool_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.PostTag","title":"<code>sankaku.models.tags.PostTag</code>","text":"<p>             Bases: <code>BaseTag</code>, <code>TagMixin</code></p> <p>Model that describes tags related to posts.</p>"},{"location":"api/models/tags/#sankaku.models.tags.PostTag.locale","title":"<code>locale: Optional[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.PostTag.version","title":"<code>version: Optional[int]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag","title":"<code>sankaku.models.tags.NestedTag</code>","text":"<p>             Bases: <code>BaseTag</code></p> <p>Model that describes tags with specific relation to certain tag on tag page.</p>"},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.post_count","title":"<code>post_count: int = Field(alias='postCount')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.cached_related","title":"<code>cached_related: Optional[List[int]] = Field(alias='cachedRelated')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.cached_related_expires_on","title":"<code>cached_related_expires_on: datetime = Field(alias='cachedRelatedExpiresOn')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.type","title":"<code>type: types.TagType = Field(alias='tagType')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.name_en","title":"<code>name_en: str = Field(alias='nameEn')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.name_ja","title":"<code>name_ja: Optional[str] = Field(alias='nameJa')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.popularity_all","title":"<code>popularity_all: Optional[float] = Field(alias='scTagPopularityAll')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.quality_all","title":"<code>quality_all: Optional[float] = Field(alias='scTagQualityAll')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.popularity_ero","title":"<code>popularity_ero: Optional[float] = Field(alias='scTagPopularityEro')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.popularity_safe","title":"<code>popularity_safe: Optional[float] = Field(alias='scTagPopularitySafe')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.quality_ero","title":"<code>quality_ero: Optional[float] = Field(alias='scTagQualityEro')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.quality_safe","title":"<code>quality_safe: Optional[float] = Field(alias='scTagQualitySafe')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.parent_tags","title":"<code>parent_tags: Optional[List[int]] = Field(alias='parentTags')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.child_tags","title":"<code>child_tags: Optional[List[int]] = Field(alias='childTags')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.pool_count","title":"<code>pool_count: int = Field(alias='poolCount')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.premium_post_count","title":"<code>premium_post_count: int = Field(alias='premPostCount')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.non_premium_post_count","title":"<code>non_premium_post_count: int = Field(alias='nonPremPostCount')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.premium_pool_count","title":"<code>premium_pool_count: int = Field(alias='premPoolCount')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.non_premium_pool_count","title":"<code>non_premium_pool_count: int = Field(alias='nonPremPoolCount')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.series_count","title":"<code>series_count: int = Field(alias='seriesCount')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.premium_series_count","title":"<code>premium_series_count: int = Field(alias='premSeriesCount')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.non_premium_series_count","title":"<code>non_premium_series_count: int = Field(alias='nonPremSeriesCount')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.is_trained","title":"<code>is_trained: bool = Field(alias='isTrained')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.child","title":"<code>child: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.parent","title":"<code>parent: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.version","title":"<code>version: Optional[int]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.BaseTranslations","title":"<code>sankaku.models.tags.BaseTranslations</code>","text":"<p>             Bases: <code>SankakuResponseModel</code></p> <p>Model that contain minimum information about tag translations.</p>"},{"location":"api/models/tags/#sankaku.models.tags.BaseTranslations.lang","title":"<code>lang: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.BaseTranslations.translation","title":"<code>translation: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.PageTagTranslations","title":"<code>sankaku.models.tags.PageTagTranslations</code>","text":"<p>             Bases: <code>BaseTranslations</code></p> <p>Model that describes page tag translations.</p>"},{"location":"api/models/tags/#sankaku.models.tags.PageTagTranslations.root_id","title":"<code>root_id: int = Field(alias='rootId')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.WikiTagTranslations","title":"<code>sankaku.models.tags.WikiTagTranslations</code>","text":"<p>             Bases: <code>BaseTranslations</code></p> <p>Model that describes wiki tag translations.</p>"},{"location":"api/models/tags/#sankaku.models.tags.WikiTagTranslations.status","title":"<code>status: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.WikiTagTranslations.opacity","title":"<code>opacity: float</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.WikiTagTranslations.id","title":"<code>id: Optional[int] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.PageTag","title":"<code>sankaku.models.tags.PageTag</code>","text":"<p>             Bases: <code>PostTag</code></p> <p>Model that describes tags on tag page.</p>"},{"location":"api/models/tags/#sankaku.models.tags.PageTag.translations","title":"<code>translations: List[PageTagTranslations]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.PageTag.related_tags","title":"<code>related_tags: List[NestedTag]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.PageTag.child_tags","title":"<code>child_tags: List[NestedTag]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.PageTag.parent_tags","title":"<code>parent_tags: List[NestedTag]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.Wiki","title":"<code>sankaku.models.tags.Wiki</code>","text":"<p>             Bases: <code>SankakuResponseModel</code></p> <p>Model that describes wiki information for specific tag.</p>"},{"location":"api/models/tags/#sankaku.models.tags.Wiki.id","title":"<code>id: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.Wiki.title","title":"<code>title: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.Wiki.body","title":"<code>body: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.Wiki.created_at","title":"<code>created_at: datetime</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.Wiki.updated_at","title":"<code>updated_at: Optional[datetime]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.Wiki.author","title":"<code>author: Author = Field(alias='user')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.Wiki.is_locked","title":"<code>is_locked: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.Wiki.version","title":"<code>version: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.WikiTag","title":"<code>sankaku.models.tags.WikiTag</code>","text":"<p>             Bases: <code>BaseTag</code>, <code>TagMixin</code></p> <p>Model that describes tag on wiki page.</p>"},{"location":"api/models/tags/#sankaku.models.tags.WikiTag.related_tags","title":"<code>related_tags: List[PostTag]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.WikiTag.child_tags","title":"<code>child_tags: List[PostTag]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.WikiTag.parent_tags","title":"<code>parent_tags: List[PostTag]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.WikiTag.alias_tags","title":"<code>alias_tags: List[PostTag]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.WikiTag.implied_tags","title":"<code>implied_tags: List[PostTag]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.WikiTag.translations","title":"<code>translations: List[WikiTagTranslations]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.WikiTag.wiki","title":"<code>wiki: Wiki</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/","title":"Documentation for <code>users.py</code>","text":""},{"location":"api/models/users/#sankaku.models.users.BaseUser","title":"<code>sankaku.models.users.BaseUser</code>","text":"<p>             Bases: <code>SankakuResponseModel</code></p> <p>User profile with a minimum amount of information.</p>"},{"location":"api/models/users/#sankaku.models.users.BaseUser.id","title":"<code>id: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.BaseUser.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.BaseUser.avatar","title":"<code>avatar: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.BaseUser.avatar_rating","title":"<code>avatar_rating: types.Rating</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.Author","title":"<code>sankaku.models.users.Author</code>","text":"<p>             Bases: <code>BaseUser</code></p> <p>Model that describes users who are the authors of posts or wiki pages.</p>"},{"location":"api/models/users/#sankaku.models.users.User","title":"<code>sankaku.models.users.User</code>","text":"<p>             Bases: <code>BaseUser</code></p> <p>User profile model for any user that has an account on website.</p>"},{"location":"api/models/users/#sankaku.models.users.User.level","title":"<code>level: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.upload_limit","title":"<code>upload_limit: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.created_at","title":"<code>created_at: datetime</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.favs_are_private","title":"<code>favs_are_private: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.avatar","title":"<code>avatar: str = Field(alias='avatar_url')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.post_upload_count","title":"<code>post_upload_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.pool_upload_count","title":"<code>pool_upload_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.comment_count","title":"<code>comment_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.post_update_count","title":"<code>post_update_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.note_update_count","title":"<code>note_update_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.wiki_update_count","title":"<code>wiki_update_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.forum_post_count","title":"<code>forum_post_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.pool_update_count","title":"<code>pool_update_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.series_update_count","title":"<code>series_update_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.tag_update_count","title":"<code>tag_update_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.artist_update_count","title":"<code>artist_update_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.last_logged_in_at","title":"<code>last_logged_in_at: Optional[datetime] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.favorite_count","title":"<code>favorite_count: Optional[int] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.post_favorite_count","title":"<code>post_favorite_count: Optional[int] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.pool_favorite_count","title":"<code>pool_favorite_count: Optional[int] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.vote_count","title":"<code>vote_count: Optional[int] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.post_vote_count","title":"<code>post_vote_count: Optional[int] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.pool_vote_count","title":"<code>pool_vote_count: Optional[int] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.recommended_posts_for_user","title":"<code>recommended_posts_for_user: Optional[int] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.subscriptions","title":"<code>subscriptions: List[str] = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.ExtendedUser","title":"<code>sankaku.models.users.ExtendedUser</code>","text":"<p>             Bases: <code>User</code></p> <p>Profile of the currently logged-in user.</p>"},{"location":"api/models/users/#sankaku.models.users.ExtendedUser.email","title":"<code>email: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.ExtendedUser.hide_ads","title":"<code>hide_ads: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.ExtendedUser.subscription_level","title":"<code>subscription_level: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.ExtendedUser.filter_content","title":"<code>filter_content: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.ExtendedUser.receive_dmails","title":"<code>receive_dmails: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.ExtendedUser.email_verification_status","title":"<code>email_verification_status: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.ExtendedUser.is_verified","title":"<code>is_verified: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.ExtendedUser.verifications_count","title":"<code>verifications_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.ExtendedUser.blacklist_is_hidden","title":"<code>blacklist_is_hidden: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.ExtendedUser.blacklisted_tags","title":"<code>blacklisted_tags: List[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.ExtendedUser.blacklisted","title":"<code>blacklisted: List[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.ExtendedUser.mfa_method","title":"<code>mfa_method: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.ExtendedUser.show_popup_version","title":"<code>show_popup_version: Optional[int]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.ExtendedUser.credits","title":"<code>credits: Optional[int]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.ExtendedUser.credits_subs","title":"<code>credits_subs: Optional[int]</code>  <code>instance-attribute</code>","text":""},{"location":"api/paginators/abc/","title":"Documentation for <code>abc.py</code>","text":""},{"location":"api/paginators/abc/#sankaku.paginators.abc.ABCPaginator","title":"<code>sankaku.paginators.abc.ABCPaginator</code>","text":"<p>             Bases: <code>ABC</code>, <code>Generic[_T]</code></p> Source code in <code>sankaku/paginators/abc.py</code> <pre><code>class ABCPaginator(ABC, Generic[_T]):\n@abstractmethod\ndef __init__(self, *args, **kwargs) -&gt; None:\n\"\"\"Abstract paginator class.\"\"\"\npass\ndef __aiter__(self) -&gt; AsyncIterator[mdl.Page[_T]]:\nreturn self\nasync def __anext__(self) -&gt; mdl.Page[_T]:\ntry:\nreturn await self.next_page()\nexcept errors.PaginatorLastPage:\nraise StopAsyncIteration\n@abstractmethod\nasync def next_page(self) -&gt; mdl.Page[_T]:\n\"\"\"Get paginator next page.\"\"\"\n@abstractmethod\ndef complete_params(self) -&gt; None:\n\"\"\"Complete params passed to paginator for further use.\"\"\"\n</code></pre>"},{"location":"api/paginators/abc/#sankaku.paginators.abc.ABCPaginator.next_page","title":"<code>next_page()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get paginator next page.</p> Source code in <code>sankaku/paginators/abc.py</code> <pre><code>@abstractmethod\nasync def next_page(self) -&gt; mdl.Page[_T]:\n\"\"\"Get paginator next page.\"\"\"\n</code></pre>"},{"location":"api/paginators/abc/#sankaku.paginators.abc.ABCPaginator.complete_params","title":"<code>complete_params()</code>  <code>abstractmethod</code>","text":"<p>Complete params passed to paginator for further use.</p> Source code in <code>sankaku/paginators/abc.py</code> <pre><code>@abstractmethod\ndef complete_params(self) -&gt; None:\n\"\"\"Complete params passed to paginator for further use.\"\"\"\n</code></pre>"},{"location":"api/paginators/paginators/","title":"Documentation for <code>paginators.py</code>","text":""},{"location":"api/paginators/paginators/#sankaku.paginators.paginators.Paginator","title":"<code>sankaku.paginators.paginators.Paginator</code>","text":"<p>             Bases: <code>ABCPaginator[_T]</code></p> Source code in <code>sankaku/paginators/paginators.py</code> <pre><code>class Paginator(ABCPaginator[_T]):\ndef __init__(\nself,\n_start: int,\n_stop: Optional[int] = None,\n_step: Optional[int] = None,\n/,\n*,\nhttp_client: HttpClient,\nurl: str,\nmodel: Type[_T],\nlimit: Annotated[int, ValueRange(1, 100)] = const.BASE_LIMIT\n) -&gt; None:\n\"\"\"Basic paginator for iteration in a certain range.\n        Range of pages can be specified in the same way as when using built-in\n        `range()`.\n        Args:\n            _start: Start of the sequence\n            _stop: End of the sequence (except this value itself)\n            _step: Step of the sequence\n            http_client: Provider used for paginator to fetch pages from server\n            url: Target API url\n            model: Type of response model to be returned inside page items\n            limit: Limit of items per each fetched page\n        \"\"\"\n# TODO: Raise error if self._start less than or equal 0.\nif _stop is None and _step is None:\nself._start = const.BASE_RANGE_START\nself._stop = _start\nself._step = const.BASE_RANGE_STEP\nelif _stop is not None and _step is None:\nself._start = _start\nself._stop = _stop\nself._step = const.BASE_RANGE_STEP\nelse:  # Case when `_stop is not None and _step is not None`.\nself._start = _start\nself._stop = _stop\nself._step = _step\nself._current_page = self._start\nself.http_client = http_client\nself.url = url\nself.model = model\nself.limit = limit\nself.params: Dict[str, str] = {}\nself.complete_params()\n@ratelimit(rps=const.BASE_RPS)\nasync def next_page(self) -&gt; mdl.Page[_T]:\n\"\"\"Get paginator next page.\"\"\"\nif self._current_page &gt;= self._stop:  # type: ignore\nraise errors.PaginatorLastPage\nresponse = await self.http_client.get(self.url, params=self.params)\njson_ = response.json\nif \"code\" in json_ and json_[\"code\"] in const.PAGE_ALLOWED_ERRORS:\nraise errors.PaginatorLastPage\nelif \"code\" in json_:\nraise errors.SankakuServerError(response.status, **response.json)\nelif json_ == [] or (isinstance(json_, dict) and not json_[\"data\"]):\nraise errors.PaginatorLastPage\nelif \"data\" in json_:\nresponse.json = json_[\"data\"]\nself._current_page += self._step  # type: ignore\nself.params[\"page\"] = str(self._current_page + 1)\nreturn self._construct_page(response.json)\ndef complete_params(self) -&gt; None:\n\"\"\"Complete params passed to paginator for further use.\"\"\"\nself.params[\"lang\"] = \"en\"\nself.params[\"page\"] = str(self._current_page + 1)\nself.params[\"limit\"] = str(self.limit)\ndef _construct_page(self, data: List[dict]) -&gt; mdl.Page[_T]:\n\"\"\"Construct and return page model.\"\"\"\nitems = [self.model(**d) for d in data]\nreturn mdl.Page[_T](\nnumber=self._current_page - self._step,  # type: ignore\nitems=items\n)\n</code></pre>"},{"location":"api/paginators/paginators/#sankaku.paginators.paginators.Paginator.__init__","title":"<code>__init__(_start, _stop=None, _step=None, /, *, http_client, url, model, limit=const.BASE_LIMIT)</code>","text":"<p>Basic paginator for iteration in a certain range. Range of pages can be specified in the same way as when using built-in <code>range()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>_start</code> <code>int</code> <p>Start of the sequence</p> required <code>_stop</code> <code>Optional[int]</code> <p>End of the sequence (except this value itself)</p> <code>None</code> <code>_step</code> <code>Optional[int]</code> <p>Step of the sequence</p> <code>None</code> <code>http_client</code> <code>HttpClient</code> <p>Provider used for paginator to fetch pages from server</p> required <code>url</code> <code>str</code> <p>Target API url</p> required <code>model</code> <code>Type[_T]</code> <p>Type of response model to be returned inside page items</p> required <code>limit</code> <code>Annotated[int, ValueRange(1, 100)]</code> <p>Limit of items per each fetched page</p> <code>const.BASE_LIMIT</code> Source code in <code>sankaku/paginators/paginators.py</code> <pre><code>def __init__(\nself,\n_start: int,\n_stop: Optional[int] = None,\n_step: Optional[int] = None,\n/,\n*,\nhttp_client: HttpClient,\nurl: str,\nmodel: Type[_T],\nlimit: Annotated[int, ValueRange(1, 100)] = const.BASE_LIMIT\n) -&gt; None:\n\"\"\"Basic paginator for iteration in a certain range.\n    Range of pages can be specified in the same way as when using built-in\n    `range()`.\n    Args:\n        _start: Start of the sequence\n        _stop: End of the sequence (except this value itself)\n        _step: Step of the sequence\n        http_client: Provider used for paginator to fetch pages from server\n        url: Target API url\n        model: Type of response model to be returned inside page items\n        limit: Limit of items per each fetched page\n    \"\"\"\n# TODO: Raise error if self._start less than or equal 0.\nif _stop is None and _step is None:\nself._start = const.BASE_RANGE_START\nself._stop = _start\nself._step = const.BASE_RANGE_STEP\nelif _stop is not None and _step is None:\nself._start = _start\nself._stop = _stop\nself._step = const.BASE_RANGE_STEP\nelse:  # Case when `_stop is not None and _step is not None`.\nself._start = _start\nself._stop = _stop\nself._step = _step\nself._current_page = self._start\nself.http_client = http_client\nself.url = url\nself.model = model\nself.limit = limit\nself.params: Dict[str, str] = {}\nself.complete_params()\n</code></pre>"},{"location":"api/paginators/paginators/#sankaku.paginators.paginators.Paginator.next_page","title":"<code>next_page()</code>  <code>async</code>","text":"<p>Get paginator next page.</p> Source code in <code>sankaku/paginators/paginators.py</code> <pre><code>@ratelimit(rps=const.BASE_RPS)\nasync def next_page(self) -&gt; mdl.Page[_T]:\n\"\"\"Get paginator next page.\"\"\"\nif self._current_page &gt;= self._stop:  # type: ignore\nraise errors.PaginatorLastPage\nresponse = await self.http_client.get(self.url, params=self.params)\njson_ = response.json\nif \"code\" in json_ and json_[\"code\"] in const.PAGE_ALLOWED_ERRORS:\nraise errors.PaginatorLastPage\nelif \"code\" in json_:\nraise errors.SankakuServerError(response.status, **response.json)\nelif json_ == [] or (isinstance(json_, dict) and not json_[\"data\"]):\nraise errors.PaginatorLastPage\nelif \"data\" in json_:\nresponse.json = json_[\"data\"]\nself._current_page += self._step  # type: ignore\nself.params[\"page\"] = str(self._current_page + 1)\nreturn self._construct_page(response.json)\n</code></pre>"},{"location":"api/paginators/paginators/#sankaku.paginators.paginators.Paginator.complete_params","title":"<code>complete_params()</code>","text":"<p>Complete params passed to paginator for further use.</p> Source code in <code>sankaku/paginators/paginators.py</code> <pre><code>def complete_params(self) -&gt; None:\n\"\"\"Complete params passed to paginator for further use.\"\"\"\nself.params[\"lang\"] = \"en\"\nself.params[\"page\"] = str(self._current_page + 1)\nself.params[\"limit\"] = str(self.limit)\n</code></pre>"},{"location":"api/paginators/paginators/#sankaku.paginators.paginators.PostPaginator","title":"<code>sankaku.paginators.paginators.PostPaginator</code>","text":"<p>             Bases: <code>Paginator[mdl.Post]</code></p> Source code in <code>sankaku/paginators/paginators.py</code> <pre><code>class PostPaginator(Paginator[mdl.Post]):\ndef __init__(\nself,\n_start: int,\n_stop: Optional[int] = None,\n_step: Optional[int] = None,\n/,\n*,\nhttp_client: HttpClient,\nurl: str = const.POSTS_URL,\nmodel: Type[mdl.Post] = mdl.Post,\nlimit: Annotated[int, ValueRange(1, 100)] = const.BASE_LIMIT,\norder: Optional[types.PostOrder] = None,\ndate: Optional[List[datetime]] = None,\nrating: Optional[types.Rating] = None,\nthreshold: Optional[Annotated[int, ValueRange(1, 100)]] = None,\nhide_posts_in_books: Optional[Literal[\"in-larger-tags\", \"always\"]] = None,\nfile_size: Optional[types.FileSize] = None,\nfile_type: Optional[types.FileType] = None,\nvideo_duration: Optional[List[int]] = None,\nrecommended_for: Optional[str] = None,\nfavorited_by: Optional[str] = None,\ntags: Optional[List[str]] = None,\nadded_by: Optional[List[str]] = None,\nvoted: Optional[str] = None\n) -&gt; None:\n\"\"\"Paginator for iteration in a certain range of post pages.\n        Range of pages can be specified in the same way as when using built-in\n        `range()`.\n        Args:\n            _start: Start of the sequence\n            _stop: End of the sequence (except this value itself)\n            _step: Step of the sequence\n            http_client: Provider used for paginator to fetch pages from server\n            url: Target API url\n            model: Type of response model to be returned inside page items\n            limit: Limit of items per each fetched page\n            order: Post order rule\n            date: Date or range of dates\n            rating: Post rating\n            threshold: Vote (quality) filter of posts\n            hide_posts_in_books: Whether show post from books or not\n            file_size: Size (aspect ratio) of mediafile\n            file_type: Type of mediafile in post\n            video_duration: Video duration in seconds or in range of seconds\n            recommended_for: Posts recommended for specified user\n            favorited_by: Posts favorited by specified user\n            tags: Tags available for search\n            added_by: Posts uploaded by specified users\n            voted: Posts voted by specified user\n        \"\"\"\nself.order = order\nself.date = date\nself.rating = rating\nself.threshold = threshold\nself.hide_posts_in_books = hide_posts_in_books\nself.file_size = file_size\nself.file_type = file_type\nself.video_duration = video_duration\nself.recommended_for = recommended_for\nself.favorited_by = favorited_by\nself.tags = tags\nself.added_by = added_by\nself.voted = voted\nsuper().__init__(\n_start,\n_stop,\n_step,\nhttp_client=http_client,\nurl=url,\nmodel=model,\nlimit=limit\n)\ndef complete_params(self) -&gt; None:  # noqa: PLR0912\n\"\"\"Complete params passed to paginator for further use.\"\"\"\nsuper().complete_params()\nif self.tags is None:\nself.tags = []\nfor k, v in self.__dict__.items():\nif v is None:\ncontinue\nelif k in {\"order\", \"rating\", \"file_type\"} and v is not types.FileType.IMAGE:  #noqa: E501\nself.tags.append(f\"{k}:{v.value}\")\nelif k in {\"threshold\", \"recommended_for\", \"voted\"}:\nself.tags.append(f\"{k}:{v}\")\nelif k == \"file_size\":\nself.tags.append(self.file_size.value)  # type: ignore\nelif k == \"date\":\ndate = \"..\".join(d.strftime(\"%Y-%m-%dT%H:%M\") for d in self.date)  # type: ignore  # noqa: E501\nself.tags.append(f\"date:{date}\")\nelif k == \"video_duration\" and self.file_type is not types.FileType.VIDEO:  # noqa\nraise errors.VideoDurationError\nelif k == \"video_duration\":\nduration = \"..\".join(str(sec) for sec in self.video_duration)  # type: ignore  # noqa: E501\nself.tags.append(f\"duration:{duration}\")\nelif k == \"favorited_by\":\nself.tags.append(f\"fav:{self.favorited_by}\")\nelif k == \"added_by\":\nfor user in self.added_by:  # type: ignore\nself.tags.append(f\"user:{user}\")\nif self.hide_posts_in_books is not None:\nself.params[\"hide_posts_in_books\"] = self.hide_posts_in_books\nif self.tags:\nself.params[\"tags\"] = \" \".join(self.tags)\n</code></pre>"},{"location":"api/paginators/paginators/#sankaku.paginators.paginators.PostPaginator.__init__","title":"<code>__init__(_start, _stop=None, _step=None, /, *, http_client, url=const.POSTS_URL, model=mdl.Post, limit=const.BASE_LIMIT, order=None, date=None, rating=None, threshold=None, hide_posts_in_books=None, file_size=None, file_type=None, video_duration=None, recommended_for=None, favorited_by=None, tags=None, added_by=None, voted=None)</code>","text":"<p>Paginator for iteration in a certain range of post pages. Range of pages can be specified in the same way as when using built-in <code>range()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>_start</code> <code>int</code> <p>Start of the sequence</p> required <code>_stop</code> <code>Optional[int]</code> <p>End of the sequence (except this value itself)</p> <code>None</code> <code>_step</code> <code>Optional[int]</code> <p>Step of the sequence</p> <code>None</code> <code>http_client</code> <code>HttpClient</code> <p>Provider used for paginator to fetch pages from server</p> required <code>url</code> <code>str</code> <p>Target API url</p> <code>const.POSTS_URL</code> <code>model</code> <code>Type[mdl.Post]</code> <p>Type of response model to be returned inside page items</p> <code>mdl.Post</code> <code>limit</code> <code>Annotated[int, ValueRange(1, 100)]</code> <p>Limit of items per each fetched page</p> <code>const.BASE_LIMIT</code> <code>order</code> <code>Optional[types.PostOrder]</code> <p>Post order rule</p> <code>None</code> <code>date</code> <code>Optional[List[datetime]]</code> <p>Date or range of dates</p> <code>None</code> <code>rating</code> <code>Optional[types.Rating]</code> <p>Post rating</p> <code>None</code> <code>threshold</code> <code>Optional[Annotated[int, ValueRange(1, 100)]]</code> <p>Vote (quality) filter of posts</p> <code>None</code> <code>hide_posts_in_books</code> <code>Optional[Literal['in-larger-tags', 'always']]</code> <p>Whether show post from books or not</p> <code>None</code> <code>file_size</code> <code>Optional[types.FileSize]</code> <p>Size (aspect ratio) of mediafile</p> <code>None</code> <code>file_type</code> <code>Optional[types.FileType]</code> <p>Type of mediafile in post</p> <code>None</code> <code>video_duration</code> <code>Optional[List[int]]</code> <p>Video duration in seconds or in range of seconds</p> <code>None</code> <code>recommended_for</code> <code>Optional[str]</code> <p>Posts recommended for specified user</p> <code>None</code> <code>favorited_by</code> <code>Optional[str]</code> <p>Posts favorited by specified user</p> <code>None</code> <code>tags</code> <code>Optional[List[str]]</code> <p>Tags available for search</p> <code>None</code> <code>added_by</code> <code>Optional[List[str]]</code> <p>Posts uploaded by specified users</p> <code>None</code> <code>voted</code> <code>Optional[str]</code> <p>Posts voted by specified user</p> <code>None</code> Source code in <code>sankaku/paginators/paginators.py</code> <pre><code>def __init__(\nself,\n_start: int,\n_stop: Optional[int] = None,\n_step: Optional[int] = None,\n/,\n*,\nhttp_client: HttpClient,\nurl: str = const.POSTS_URL,\nmodel: Type[mdl.Post] = mdl.Post,\nlimit: Annotated[int, ValueRange(1, 100)] = const.BASE_LIMIT,\norder: Optional[types.PostOrder] = None,\ndate: Optional[List[datetime]] = None,\nrating: Optional[types.Rating] = None,\nthreshold: Optional[Annotated[int, ValueRange(1, 100)]] = None,\nhide_posts_in_books: Optional[Literal[\"in-larger-tags\", \"always\"]] = None,\nfile_size: Optional[types.FileSize] = None,\nfile_type: Optional[types.FileType] = None,\nvideo_duration: Optional[List[int]] = None,\nrecommended_for: Optional[str] = None,\nfavorited_by: Optional[str] = None,\ntags: Optional[List[str]] = None,\nadded_by: Optional[List[str]] = None,\nvoted: Optional[str] = None\n) -&gt; None:\n\"\"\"Paginator for iteration in a certain range of post pages.\n    Range of pages can be specified in the same way as when using built-in\n    `range()`.\n    Args:\n        _start: Start of the sequence\n        _stop: End of the sequence (except this value itself)\n        _step: Step of the sequence\n        http_client: Provider used for paginator to fetch pages from server\n        url: Target API url\n        model: Type of response model to be returned inside page items\n        limit: Limit of items per each fetched page\n        order: Post order rule\n        date: Date or range of dates\n        rating: Post rating\n        threshold: Vote (quality) filter of posts\n        hide_posts_in_books: Whether show post from books or not\n        file_size: Size (aspect ratio) of mediafile\n        file_type: Type of mediafile in post\n        video_duration: Video duration in seconds or in range of seconds\n        recommended_for: Posts recommended for specified user\n        favorited_by: Posts favorited by specified user\n        tags: Tags available for search\n        added_by: Posts uploaded by specified users\n        voted: Posts voted by specified user\n    \"\"\"\nself.order = order\nself.date = date\nself.rating = rating\nself.threshold = threshold\nself.hide_posts_in_books = hide_posts_in_books\nself.file_size = file_size\nself.file_type = file_type\nself.video_duration = video_duration\nself.recommended_for = recommended_for\nself.favorited_by = favorited_by\nself.tags = tags\nself.added_by = added_by\nself.voted = voted\nsuper().__init__(\n_start,\n_stop,\n_step,\nhttp_client=http_client,\nurl=url,\nmodel=model,\nlimit=limit\n)\n</code></pre>"},{"location":"api/paginators/paginators/#sankaku.paginators.paginators.PostPaginator.complete_params","title":"<code>complete_params()</code>","text":"<p>Complete params passed to paginator for further use.</p> Source code in <code>sankaku/paginators/paginators.py</code> <pre><code>def complete_params(self) -&gt; None:  # noqa: PLR0912\n\"\"\"Complete params passed to paginator for further use.\"\"\"\nsuper().complete_params()\nif self.tags is None:\nself.tags = []\nfor k, v in self.__dict__.items():\nif v is None:\ncontinue\nelif k in {\"order\", \"rating\", \"file_type\"} and v is not types.FileType.IMAGE:  #noqa: E501\nself.tags.append(f\"{k}:{v.value}\")\nelif k in {\"threshold\", \"recommended_for\", \"voted\"}:\nself.tags.append(f\"{k}:{v}\")\nelif k == \"file_size\":\nself.tags.append(self.file_size.value)  # type: ignore\nelif k == \"date\":\ndate = \"..\".join(d.strftime(\"%Y-%m-%dT%H:%M\") for d in self.date)  # type: ignore  # noqa: E501\nself.tags.append(f\"date:{date}\")\nelif k == \"video_duration\" and self.file_type is not types.FileType.VIDEO:  # noqa\nraise errors.VideoDurationError\nelif k == \"video_duration\":\nduration = \"..\".join(str(sec) for sec in self.video_duration)  # type: ignore  # noqa: E501\nself.tags.append(f\"duration:{duration}\")\nelif k == \"favorited_by\":\nself.tags.append(f\"fav:{self.favorited_by}\")\nelif k == \"added_by\":\nfor user in self.added_by:  # type: ignore\nself.tags.append(f\"user:{user}\")\nif self.hide_posts_in_books is not None:\nself.params[\"hide_posts_in_books\"] = self.hide_posts_in_books\nif self.tags:\nself.params[\"tags\"] = \" \".join(self.tags)\n</code></pre>"},{"location":"api/paginators/paginators/#sankaku.paginators.paginators.TagPaginator","title":"<code>sankaku.paginators.paginators.TagPaginator</code>","text":"<p>             Bases: <code>Paginator[mdl.PageTag]</code></p> Source code in <code>sankaku/paginators/paginators.py</code> <pre><code>class TagPaginator(Paginator[mdl.PageTag]):\ndef __init__(\nself,\n_start: int,\n_stop: Optional[int] = None,\n_step: Optional[int] = None,\n/,\n*,\nhttp_client: HttpClient,\nurl: str = const.TAGS_URL,\nmodel: Type[mdl.PageTag] = mdl.PageTag,\nlimit: Annotated[int, ValueRange(1, 100)] = const.BASE_LIMIT,\ntag_type: Optional[types.TagType] = None,\norder: Optional[types.TagOrder] = None,\nrating: Optional[types.Rating] = None,\nmax_post_count: Optional[int] = None,\nsort_parameter: Optional[types.SortParameter] = None,\nsort_direction: Optional[types.SortDirection] = None\n) -&gt; None:\n\"\"\"Paginator for iteration in a certain range of tag pages.\n        Range of pages can be specified in the same way as when using built-in\n        `range()`.\n        Args:\n            _start: Start of the sequence\n            _stop: End of the sequence (except this value itself)\n            _step: Step of the sequence\n            http_client: Provider used for paginator to fetch pages from server\n            url: Target API url\n            model: Type of response model to be returned inside page items\n            limit: Limit of items per each fetched page\n            tag_type: Tag type filter\n            order: Tag order rule\n            rating: Tag rating\n            max_post_count: Upper threshold for number of posts with tags found\n            sort_parameter: Tag sorting parameter\n            sort_direction: Tag sorting direction\n        \"\"\"\nself.tag_type = tag_type\nself.order = order\nself.rating = rating\nself.max_post_count = max_post_count\nself.sort_parameter = sort_parameter\nself.sort_direction = sort_direction or types.SortDirection.DESC\nsuper().__init__(\n_start,\n_stop,\n_step,\nhttp_client=http_client,\nurl=url,\nmodel=model,\nlimit=limit\n)\ndef complete_params(self) -&gt; None:\n\"\"\"Complete params passed to paginator for further use.\"\"\"\nsuper().complete_params()\nif self.tag_type is not None:\nself.params[\"types[]\"] = str(self.tag_type.value)\nif self.order is not None:\nself.params[\"order\"] = self.order.value\nif self.rating is not None:\nself.params[\"rating\"] = self.rating.value\nif self.max_post_count is not None:\nself.params[\"amount\"] = str(self.max_post_count)\nif self.sort_parameter is not None:\nself.params.update(\nsortBy=self.sort_parameter.value,\nsortDirection=self.sort_direction.value\n)\n</code></pre>"},{"location":"api/paginators/paginators/#sankaku.paginators.paginators.TagPaginator.__init__","title":"<code>__init__(_start, _stop=None, _step=None, /, *, http_client, url=const.TAGS_URL, model=mdl.PageTag, limit=const.BASE_LIMIT, tag_type=None, order=None, rating=None, max_post_count=None, sort_parameter=None, sort_direction=None)</code>","text":"<p>Paginator for iteration in a certain range of tag pages. Range of pages can be specified in the same way as when using built-in <code>range()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>_start</code> <code>int</code> <p>Start of the sequence</p> required <code>_stop</code> <code>Optional[int]</code> <p>End of the sequence (except this value itself)</p> <code>None</code> <code>_step</code> <code>Optional[int]</code> <p>Step of the sequence</p> <code>None</code> <code>http_client</code> <code>HttpClient</code> <p>Provider used for paginator to fetch pages from server</p> required <code>url</code> <code>str</code> <p>Target API url</p> <code>const.TAGS_URL</code> <code>model</code> <code>Type[mdl.PageTag]</code> <p>Type of response model to be returned inside page items</p> <code>mdl.PageTag</code> <code>limit</code> <code>Annotated[int, ValueRange(1, 100)]</code> <p>Limit of items per each fetched page</p> <code>const.BASE_LIMIT</code> <code>tag_type</code> <code>Optional[types.TagType]</code> <p>Tag type filter</p> <code>None</code> <code>order</code> <code>Optional[types.TagOrder]</code> <p>Tag order rule</p> <code>None</code> <code>rating</code> <code>Optional[types.Rating]</code> <p>Tag rating</p> <code>None</code> <code>max_post_count</code> <code>Optional[int]</code> <p>Upper threshold for number of posts with tags found</p> <code>None</code> <code>sort_parameter</code> <code>Optional[types.SortParameter]</code> <p>Tag sorting parameter</p> <code>None</code> <code>sort_direction</code> <code>Optional[types.SortDirection]</code> <p>Tag sorting direction</p> <code>None</code> Source code in <code>sankaku/paginators/paginators.py</code> <pre><code>def __init__(\nself,\n_start: int,\n_stop: Optional[int] = None,\n_step: Optional[int] = None,\n/,\n*,\nhttp_client: HttpClient,\nurl: str = const.TAGS_URL,\nmodel: Type[mdl.PageTag] = mdl.PageTag,\nlimit: Annotated[int, ValueRange(1, 100)] = const.BASE_LIMIT,\ntag_type: Optional[types.TagType] = None,\norder: Optional[types.TagOrder] = None,\nrating: Optional[types.Rating] = None,\nmax_post_count: Optional[int] = None,\nsort_parameter: Optional[types.SortParameter] = None,\nsort_direction: Optional[types.SortDirection] = None\n) -&gt; None:\n\"\"\"Paginator for iteration in a certain range of tag pages.\n    Range of pages can be specified in the same way as when using built-in\n    `range()`.\n    Args:\n        _start: Start of the sequence\n        _stop: End of the sequence (except this value itself)\n        _step: Step of the sequence\n        http_client: Provider used for paginator to fetch pages from server\n        url: Target API url\n        model: Type of response model to be returned inside page items\n        limit: Limit of items per each fetched page\n        tag_type: Tag type filter\n        order: Tag order rule\n        rating: Tag rating\n        max_post_count: Upper threshold for number of posts with tags found\n        sort_parameter: Tag sorting parameter\n        sort_direction: Tag sorting direction\n    \"\"\"\nself.tag_type = tag_type\nself.order = order\nself.rating = rating\nself.max_post_count = max_post_count\nself.sort_parameter = sort_parameter\nself.sort_direction = sort_direction or types.SortDirection.DESC\nsuper().__init__(\n_start,\n_stop,\n_step,\nhttp_client=http_client,\nurl=url,\nmodel=model,\nlimit=limit\n)\n</code></pre>"},{"location":"api/paginators/paginators/#sankaku.paginators.paginators.TagPaginator.complete_params","title":"<code>complete_params()</code>","text":"<p>Complete params passed to paginator for further use.</p> Source code in <code>sankaku/paginators/paginators.py</code> <pre><code>def complete_params(self) -&gt; None:\n\"\"\"Complete params passed to paginator for further use.\"\"\"\nsuper().complete_params()\nif self.tag_type is not None:\nself.params[\"types[]\"] = str(self.tag_type.value)\nif self.order is not None:\nself.params[\"order\"] = self.order.value\nif self.rating is not None:\nself.params[\"rating\"] = self.rating.value\nif self.max_post_count is not None:\nself.params[\"amount\"] = str(self.max_post_count)\nif self.sort_parameter is not None:\nself.params.update(\nsortBy=self.sort_parameter.value,\nsortDirection=self.sort_direction.value\n)\n</code></pre>"},{"location":"api/paginators/paginators/#sankaku.paginators.paginators.BookPaginator","title":"<code>sankaku.paginators.paginators.BookPaginator</code>","text":"<p>             Bases: <code>Paginator[mdl.PageBook]</code></p> Source code in <code>sankaku/paginators/paginators.py</code> <pre><code>class BookPaginator(Paginator[mdl.PageBook]):\ndef __init__(\nself,\n_start: int,\n_stop: Optional[int] = None,\n_step: Optional[int] = None,\n/,\n*,\nhttp_client: HttpClient,\nurl: str = const.BOOKS_URL,\nmodel: Type[mdl.PageBook] = mdl.PageBook,\nlimit: Annotated[int, ValueRange(1, 100)] = const.BASE_LIMIT,\norder: Optional[types.BookOrder] = None,\nrating: Optional[types.Rating] = None,\nrecommended_for: Optional[str] = None,\nfavorited_by: Optional[str] = None,\ntags: Optional[List[str]] = None,\nadded_by: Optional[List[str]] = None,\nvoted: Optional[str] = None\n) -&gt; None:\n\"\"\"Paginator for iteration in a certain range of book (pool) pages.\n        Range of pages can be specified in the same way as when using built-in\n        `range()`.\n        Args:\n            _start: Start of the sequence\n            _stop: End of the sequence (except this value itself)\n            _step: Step of the sequence\n            http_client: Provider used for paginator to fetch pages from server\n            url: Target API url\n            model: Type of response model to be returned inside page items\n            limit: Limit of items per each fetched page\n            order: Book order rule\n            rating: Books rating\n            recommended_for: Books recommended for specified user\n            favorited_by: Books favorited by specified user\n            tags: Tags available for search\n            added_by: Books uploaded by specified users\n            voted: Books voted by specified user\n        \"\"\"\nself.order = order\nself.rating = rating\nself.recommended_for = recommended_for\nself.favorited_by = favorited_by\nself.tags = tags\nself.added_by = added_by\nself.voted = voted\nsuper().__init__(\n_start,\n_stop,\n_step,\nhttp_client=http_client,\nurl=url,\nmodel=model,\nlimit=limit\n)\ndef complete_params(self) -&gt; None:\n\"\"\"Complete params passed to paginator for further use.\"\"\"\nsuper().complete_params()\nif self.tags is None:\nself.tags = []\nfor k, v in self.__dict__.items():\nif v is None:\ncontinue\nelif k in {\"order\", \"rating\"}:\nself.tags.append(f\"{k}:{v.value}\")\nelif k in {\"recommended_for\", \"voted\"}:\nself.tags.append(f\"{k}:{v}\")\nelif k == \"favorited_by\":\nself.tags.append(f\"fav:{self.favorited_by}\")\nelif k == \"added_by\":\nfor user in self.added_by:  # type: ignore[union-attr]\nself.tags.append(f\"user:{user}\")\nif self.tags:\nself.params[\"tags\"] = \" \".join(self.tags)\n</code></pre>"},{"location":"api/paginators/paginators/#sankaku.paginators.paginators.BookPaginator.__init__","title":"<code>__init__(_start, _stop=None, _step=None, /, *, http_client, url=const.BOOKS_URL, model=mdl.PageBook, limit=const.BASE_LIMIT, order=None, rating=None, recommended_for=None, favorited_by=None, tags=None, added_by=None, voted=None)</code>","text":"<p>Paginator for iteration in a certain range of book (pool) pages. Range of pages can be specified in the same way as when using built-in <code>range()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>_start</code> <code>int</code> <p>Start of the sequence</p> required <code>_stop</code> <code>Optional[int]</code> <p>End of the sequence (except this value itself)</p> <code>None</code> <code>_step</code> <code>Optional[int]</code> <p>Step of the sequence</p> <code>None</code> <code>http_client</code> <code>HttpClient</code> <p>Provider used for paginator to fetch pages from server</p> required <code>url</code> <code>str</code> <p>Target API url</p> <code>const.BOOKS_URL</code> <code>model</code> <code>Type[mdl.PageBook]</code> <p>Type of response model to be returned inside page items</p> <code>mdl.PageBook</code> <code>limit</code> <code>Annotated[int, ValueRange(1, 100)]</code> <p>Limit of items per each fetched page</p> <code>const.BASE_LIMIT</code> <code>order</code> <code>Optional[types.BookOrder]</code> <p>Book order rule</p> <code>None</code> <code>rating</code> <code>Optional[types.Rating]</code> <p>Books rating</p> <code>None</code> <code>recommended_for</code> <code>Optional[str]</code> <p>Books recommended for specified user</p> <code>None</code> <code>favorited_by</code> <code>Optional[str]</code> <p>Books favorited by specified user</p> <code>None</code> <code>tags</code> <code>Optional[List[str]]</code> <p>Tags available for search</p> <code>None</code> <code>added_by</code> <code>Optional[List[str]]</code> <p>Books uploaded by specified users</p> <code>None</code> <code>voted</code> <code>Optional[str]</code> <p>Books voted by specified user</p> <code>None</code> Source code in <code>sankaku/paginators/paginators.py</code> <pre><code>def __init__(\nself,\n_start: int,\n_stop: Optional[int] = None,\n_step: Optional[int] = None,\n/,\n*,\nhttp_client: HttpClient,\nurl: str = const.BOOKS_URL,\nmodel: Type[mdl.PageBook] = mdl.PageBook,\nlimit: Annotated[int, ValueRange(1, 100)] = const.BASE_LIMIT,\norder: Optional[types.BookOrder] = None,\nrating: Optional[types.Rating] = None,\nrecommended_for: Optional[str] = None,\nfavorited_by: Optional[str] = None,\ntags: Optional[List[str]] = None,\nadded_by: Optional[List[str]] = None,\nvoted: Optional[str] = None\n) -&gt; None:\n\"\"\"Paginator for iteration in a certain range of book (pool) pages.\n    Range of pages can be specified in the same way as when using built-in\n    `range()`.\n    Args:\n        _start: Start of the sequence\n        _stop: End of the sequence (except this value itself)\n        _step: Step of the sequence\n        http_client: Provider used for paginator to fetch pages from server\n        url: Target API url\n        model: Type of response model to be returned inside page items\n        limit: Limit of items per each fetched page\n        order: Book order rule\n        rating: Books rating\n        recommended_for: Books recommended for specified user\n        favorited_by: Books favorited by specified user\n        tags: Tags available for search\n        added_by: Books uploaded by specified users\n        voted: Books voted by specified user\n    \"\"\"\nself.order = order\nself.rating = rating\nself.recommended_for = recommended_for\nself.favorited_by = favorited_by\nself.tags = tags\nself.added_by = added_by\nself.voted = voted\nsuper().__init__(\n_start,\n_stop,\n_step,\nhttp_client=http_client,\nurl=url,\nmodel=model,\nlimit=limit\n)\n</code></pre>"},{"location":"api/paginators/paginators/#sankaku.paginators.paginators.BookPaginator.complete_params","title":"<code>complete_params()</code>","text":"<p>Complete params passed to paginator for further use.</p> Source code in <code>sankaku/paginators/paginators.py</code> <pre><code>def complete_params(self) -&gt; None:\n\"\"\"Complete params passed to paginator for further use.\"\"\"\nsuper().complete_params()\nif self.tags is None:\nself.tags = []\nfor k, v in self.__dict__.items():\nif v is None:\ncontinue\nelif k in {\"order\", \"rating\"}:\nself.tags.append(f\"{k}:{v.value}\")\nelif k in {\"recommended_for\", \"voted\"}:\nself.tags.append(f\"{k}:{v}\")\nelif k == \"favorited_by\":\nself.tags.append(f\"fav:{self.favorited_by}\")\nelif k == \"added_by\":\nfor user in self.added_by:  # type: ignore[union-attr]\nself.tags.append(f\"user:{user}\")\nif self.tags:\nself.params[\"tags\"] = \" \".join(self.tags)\n</code></pre>"},{"location":"api/paginators/paginators/#sankaku.paginators.paginators.UserPaginator","title":"<code>sankaku.paginators.paginators.UserPaginator</code>","text":"<p>             Bases: <code>Paginator[mdl.User]</code></p> Source code in <code>sankaku/paginators/paginators.py</code> <pre><code>class UserPaginator(Paginator[mdl.User]):\ndef __init__(\nself,\n_start: int,\n_stop: Optional[int] = None,\n_step: Optional[int] = None,\n/,\n*,\nhttp_client: HttpClient,\nurl: str = const.USERS_URL,\nmodel: Type[mdl.User] = mdl.User,\nlimit: Annotated[int, ValueRange(1, 100)] = const.BASE_LIMIT,\norder: Optional[types.UserOrder] = None,\nlevel: Optional[types.UserLevel] = None\n) -&gt; None:\n\"\"\"Paginator for iteration in a certain range of user profiles pages.\n        Range of pages can be specified in the same way as when using built-in\n        `range()`.\n        Args:\n            _start: Start of the sequence\n            _stop: End of the sequence (except this value itself)\n            _step: Step of the sequence\n            http_client: Provider used for paginator to fetch pages from server\n            url: Target API url\n            model: Type of response model to be returned inside page items\n            limit: Limit of items per each fetched page\n            order: User order rule\n            level: User level type\n        \"\"\"\nself.order = order\nself.level = level\nsuper().__init__(\n_start,\n_stop,\n_step,\nhttp_client=http_client,\nurl=url,\nmodel=model,\nlimit=limit\n)\ndef complete_params(self) -&gt; None:\n\"\"\"Complete params passed to paginator for further use.\"\"\"\nsuper().complete_params()\nif self.order is not None:\nself.params[\"order\"] = self.order.value\nif self.level is not None:\nself.params[\"level\"] = str(self.level.value)\n</code></pre>"},{"location":"api/paginators/paginators/#sankaku.paginators.paginators.UserPaginator.__init__","title":"<code>__init__(_start, _stop=None, _step=None, /, *, http_client, url=const.USERS_URL, model=mdl.User, limit=const.BASE_LIMIT, order=None, level=None)</code>","text":"<p>Paginator for iteration in a certain range of user profiles pages. Range of pages can be specified in the same way as when using built-in <code>range()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>_start</code> <code>int</code> <p>Start of the sequence</p> required <code>_stop</code> <code>Optional[int]</code> <p>End of the sequence (except this value itself)</p> <code>None</code> <code>_step</code> <code>Optional[int]</code> <p>Step of the sequence</p> <code>None</code> <code>http_client</code> <code>HttpClient</code> <p>Provider used for paginator to fetch pages from server</p> required <code>url</code> <code>str</code> <p>Target API url</p> <code>const.USERS_URL</code> <code>model</code> <code>Type[mdl.User]</code> <p>Type of response model to be returned inside page items</p> <code>mdl.User</code> <code>limit</code> <code>Annotated[int, ValueRange(1, 100)]</code> <p>Limit of items per each fetched page</p> <code>const.BASE_LIMIT</code> <code>order</code> <code>Optional[types.UserOrder]</code> <p>User order rule</p> <code>None</code> <code>level</code> <code>Optional[types.UserLevel]</code> <p>User level type</p> <code>None</code> Source code in <code>sankaku/paginators/paginators.py</code> <pre><code>def __init__(\nself,\n_start: int,\n_stop: Optional[int] = None,\n_step: Optional[int] = None,\n/,\n*,\nhttp_client: HttpClient,\nurl: str = const.USERS_URL,\nmodel: Type[mdl.User] = mdl.User,\nlimit: Annotated[int, ValueRange(1, 100)] = const.BASE_LIMIT,\norder: Optional[types.UserOrder] = None,\nlevel: Optional[types.UserLevel] = None\n) -&gt; None:\n\"\"\"Paginator for iteration in a certain range of user profiles pages.\n    Range of pages can be specified in the same way as when using built-in\n    `range()`.\n    Args:\n        _start: Start of the sequence\n        _stop: End of the sequence (except this value itself)\n        _step: Step of the sequence\n        http_client: Provider used for paginator to fetch pages from server\n        url: Target API url\n        model: Type of response model to be returned inside page items\n        limit: Limit of items per each fetched page\n        order: User order rule\n        level: User level type\n    \"\"\"\nself.order = order\nself.level = level\nsuper().__init__(\n_start,\n_stop,\n_step,\nhttp_client=http_client,\nurl=url,\nmodel=model,\nlimit=limit\n)\n</code></pre>"},{"location":"api/paginators/paginators/#sankaku.paginators.paginators.UserPaginator.complete_params","title":"<code>complete_params()</code>","text":"<p>Complete params passed to paginator for further use.</p> Source code in <code>sankaku/paginators/paginators.py</code> <pre><code>def complete_params(self) -&gt; None:\n\"\"\"Complete params passed to paginator for further use.\"\"\"\nsuper().complete_params()\nif self.order is not None:\nself.params[\"order\"] = self.order.value\nif self.level is not None:\nself.params[\"level\"] = str(self.level.value)\n</code></pre>"},{"location":"clients/","title":"Introduction","text":"<p>There are several clients present and each of them has different responsibilities, but for simplicity they all are merged into one client with multiple inheritance - <code>SankakuClient()</code>. If you want to use any specific client, then you should import it explicitly: <code>from sankaku.clients import &lt;client&gt;</code>.</p>"},{"location":"clients/#specifying-the-range","title":"Specifying the range","text":"<p>It's worth mentioning that any client methods with return type <code>AsyncIterator</code> supports specyfing of range (except <code>PostClient.get_post_comments()</code>) in the  same way as with using python built-in <code>range(_start, _stop, _step)</code> function.</p> <p>The only restrictions when setting range:</p> <ul> <li>Initial value can't be 0;</li> <li>Can't use negative <code>_step</code>;</li> <li><code>_start</code> value should always be less than <code>_end</code>.</li> </ul>"},{"location":"clients/ai-client/","title":"About AIClient","text":"<p>Recently Sankaku Complex developers released feature to generate posts by usage of neural networks. So AIClient is responsible for managing API requests to AI-related content.</p>"},{"location":"clients/ai-client/#note","title":"Note","text":"<p>Because AI is feature for premium users, AI client look a bit poor.</p>"},{"location":"clients/ai-client/#browsing-posts-with-aiclient","title":"Browsing posts with AIClient","text":"<p>For non-premium users there is restriction to directly view posts created by AI:</p> <p></p> <p>But this restriction can be circumvented by sending requests directly via API.</p> <p>Here is example of post browsing, using AIClient:</p> <pre><code>import asyncio\nfrom sankaku.clients import AIClient\nfrom sankaku import types\nasync def main():\nclient = AIClient()\nai_posts = []\nasync for post in client.browse_ai_posts(90, 200):  # Specify range\nif post.rating is types.Rating.SAFE:  # Filter nsfw content\nai_posts.append(post)\nprint(\"\\n\".join(post.file_url for post in ai_posts if post.file_url))\nasyncio.run(main())\n</code></pre>"},{"location":"clients/ai-client/#getting-specific-ai-post","title":"Getting specific AI post","text":"<p>If there is situation when you know ID of the post and want to fetch its data from server, you can do it like this:</p> <pre><code>import asyncio\nfrom sankaku.clients import AIClient\nasync def main():\npost_id: int = 23432  # Here the ID of the post you interested in\nclient = AIClient()\npost = await client.get_ai_post(post_id)\nprint(post.file_url)\nasyncio.run(main())\n</code></pre>"},{"location":"clients/book-client/","title":"About BookClient","text":"<p>BookClient resembles PostClient in terms of functionality. It's because posts and books are strongly related.</p>"},{"location":"clients/book-client/#browsing-books-with-bookclient","title":"Browsing books with BookClient","text":"<p>The following code shows how to browse pages with books:</p> <pre><code>import asyncio\nfrom sankaku.clients import BookClient\nfrom sankaku import types\nfrom sankaku.constants import LAST_RANGE_ITEM\nasync def main():\nclient = BookClient()\nasync for book in client.browse_books(\nLAST_RANGE_ITEM,\nfavorited_by=\"Nigredo\",\norder=types.BookOrder.POPULARITY\n):\nprint(book.name, book.description)\nasyncio.run(main())\n</code></pre> <p>In the example above we used method <code>browse_books()</code> to get all books favorited by one specific user ('Nigredo' in our case). Predefined constant <code>LAST_RANGE_ITEM</code> is just an integer number high enough to be ensured that we will reach end of iteration.</p>"},{"location":"clients/book-client/#getting-books-related-to-specific-post","title":"Getting books related to specific post","text":"<p>If specific post id has some books as its parents, you can use <code>get_related_books()</code> method to get such books:</p> <pre><code>import asyncio\nfrom sankaku.clients import BookClient\nfrom sankaku.constants import LAST_RANGE_ITEM\nasync def main():\nclient = BookClient()\npost_id: int = ...\nrelated_books = []\nasync for book in client.get_related_books(LAST_RANGE_ITEM, post_id=post_id):\nrelated_books.append(book)\nasyncio.run(main())\n</code></pre>"},{"location":"clients/book-client/#getting-specific-book-by-its-id","title":"Getting specific book by its ID","text":"<p>If you know specific book ID then you can get remaining parameters. Peculiarity of that method is that it returns the whole book information (including another posts that are part of book):</p> <pre><code>import asyncio\nfrom sankaku.clients import BookClient\nasync def main():\nclient = BookClient()\nbook_id: int = 14562\nbook = await client.get_book(book_id)\nprint(\"\\n\".join(post.file_url for post in book.posts))\nasyncio.run(main())\n</code></pre>"},{"location":"clients/book-client/#about-the-remaining-methods","title":"About the remaining methods","text":"<p>All the remaining methods inside their definitions invoke method <code>browse_books()</code> with certain arguments so there is no need to thoroughly consider them. Also, all the remaining mehtods require authentication.</p>"},{"location":"clients/post-client/","title":"About PostClient","text":"<p>Client for post browsing has several times more methods than other clients. That applies to <code>browse_posts()</code> method too.</p>"},{"location":"clients/post-client/#browsing-posts-with-post-client","title":"Browsing posts with post client","text":"<p>Here simple code snippet with post browsing:</p> <pre><code>import asyncio\nfrom datetime import datetime\nfrom sankaku.clients import PostClient\nfrom sankaku import types\nasync def main():\nclient = PostClient()\nasync for post in client.browse_posts(\n100,\norder=types.PostOrder.QUALITY,\ndate=[datetime(2020, 1, 12), datetime(2022, 1, 12)],\ntags=[\"animated\"],\nfile_type=types.FileType.VIDEO,\nrating=types.Rating.SAFE\n):\nprint(post.file_url)\nasyncio.run(main())\n</code></pre> <p>In the example above we specified:</p> <ul> <li>amount of posts that we want to fetch;</li> <li>rule which will be used to sort posts before fetching;</li> <li>date range of posts;</li> <li>tags by which posts will be filtered;</li> <li>type of posts (e.g. gif, images or video);</li> <li>content rating of posts (safe, questionable or explicit (nsfw)).</li> </ul>"},{"location":"clients/post-client/#getting-specific-post-by-its-id","title":"Getting specific post by its ID","text":"<p>You can get specific post by its ID like that:</p> <pre><code>import asyncio\nfrom sankaku.clients import PostClient\nasync def main():\npost_id: int = 25742064  # Here the ID of the post you interested in\nclient = PostClient()\npost = await client.get_post(post_id)\nprint(post.file_url)\nasyncio.run(main())\n</code></pre>"},{"location":"clients/post-client/#about-the-remaining-methods","title":"About the remaining methods","text":"<p>Almost all the remaining methods inside their definitions invoke method <code>browse_posts()</code> with certain arguments so there is no need to thoroughly consider them. But it's worth mentioning that methods <code>get_recommended_posts()</code> and <code>get_favorited_posts()</code> require authorization.</p>"},{"location":"clients/tag-client/","title":"About TagClient","text":"<p>Tag client has methods for browsing pages with tags and for fetching specific tag.</p>"},{"location":"clients/tag-client/#browsing-tags-with-tagclient","title":"Browsing tags with TagClient","text":"<p>Unlike AI-generated posts, whose browsing is restricted and can't be parametrized, method <code>browse_tags()</code> can be parametrized in same way as on website:</p> <pre><code>import asyncio\nfrom sankaku.clients import TagClient\nfrom sankaku import types\nasync def main():\nclient = TagClient()\nasync for tag in client.browse_tags(\n30,  # Specify amount of tags to fetch from server\norder=types.TagOrder.QUALITY,\nsort_parameter=types.SortParameter.POST_COUNT,\nsort_direction=types.SortDirection.DESC\n):\nprint(tag.name, tag.rating, tag.type)\nasyncio.run(main())\n</code></pre>"},{"location":"clients/tag-client/#getting-specific-tag","title":"Getting specific tag","text":"<p>Unlike posts, AI-generated posts or books, specific tag can be returned by its name or id:</p> <pre><code>import asyncio\nfrom sankaku.clients import TagClient\nasync def main():\nclient = TagClient()\ntag_id: int = 100\ntag_name: str = \"mirco_cabbia\"\ntag_by_id = await client.get_tag(tag_id)\ntag_by_name = await client.get_tag(tag_name)\nprint(tag_by_id)\nprint(tag_by_name)\nasyncio.run(main())\n</code></pre>"},{"location":"clients/user-client/","title":"About UserClient","text":"<p>Methods of UserClient enables you browse pages with users or get specific user.</p>"},{"location":"clients/user-client/#browsing-users-with-userclient","title":"Browsing users with UserClient","text":"<p>User browsing can be parametrized by specifying Order rule or level of users:</p> <pre><code>import asyncio\nfrom datetime import datetime\nfrom sankaku.clients import UserClient\nfrom sankaku import types\nasync def main():\nclient = UserClient()\nasync for user in client.browse_users(\n1000,\norder=types.UserOrder.OLDEST,\nlevel=types.UserLevel.CONTRIBUTOR\n):\nprint(user.created_at &lt; datetime(2020, 12, 18).astimezone())\nasyncio.run(main())\n</code></pre>"},{"location":"clients/user-client/#getting-specific-user","title":"Getting specific user","text":"<p>By analogy with <code>get_tag()</code> method you can get information about specific user by its nickname or id:</p> <pre><code>import asyncio\nfrom sankaku.clients import UserClient\nasync def main():\nclient = UserClient()\nuser_id: int = 3242\nuser_name: str = \"reichan\"\nuser_by_id = await client.get_user(user_id)\nuser_by_name = await client.get_user(user_name)\nprint(user_by_id)\nprint(user_by_name)\nasyncio.run(main())\n</code></pre>"}]}