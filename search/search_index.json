{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to sankaku documentation","text":"<p>It is an unofficial API wrapper for Sankaku Complex with type-hinting, pydantic data validation and an optional logging support with loguru.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Type-hints</li> <li>Deserialization of raw json data thanks to pydantic models</li> <li>Enumerations for API request parameters to provide better user experience <p>For instance, you can type <code>types.TagType.ARTIST</code> instead of <code>types[]=1</code></p> </li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.7+</li> <li>aiohttp</li> <li>pydantic</li> <li>loguru</li> <li>aiohttp-retry</li> <li>typing_extensions; python_version &lt; '3.10'</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>To install sankaku via pip write following line of code in your terminal:</p> <pre><code>pip install sankaku\n</code></pre> <p>To install the sankaku via Docker, you can follow these steps:</p>"},{"location":"#step-1-install-docker","title":"Step 1: Install Docker","text":"<p>Ensure that Docker is installed on your machine. If Docker is not already installed, you can download and install it from the official Docker website.</p>"},{"location":"#step-2-use-docker-to-install-sankaku","title":"Step 2: Use docker to install sankaku","text":"<p>Open a command prompt. Navigate to the directory where you want to install Sankaku. Type the following command:</p> <pre><code>git clone https://github.com/zerex290/sankaku.git\ncd sankaku\ndocker run -it --name sankaku -w /opt -v$(pwd):/opt python:3 bash\n</code></pre>"},{"location":"#usage-example","title":"Usage example","text":"<pre><code>import asyncio\nfrom sankaku import SankakuClient\nasync def main():\nclient = SankakuClient()\npost = await client.get_post(25742064)\nprint(f\"Rating: {post.rating} | Created: {post.created_at}\")\n# \"Rating: Rating.QUESTIONABLE | Created: 2021-08-01 23:18:52+03:00\"\nawait client.login(access_token=\"token\")\n# Or you can authorize by credentials:\n# await client.login(login=\"nickname or email\", password=\"password\")\nasync for book in client.get_recently_read_books():\n...\nasyncio.run(main())\n</code></pre>"},{"location":"authorization/","title":"The authorization process","text":"<p>Authorization on Sankaku Complex can be performed in two ways: - via access token - via credentials (login and password)</p>"},{"location":"authorization/#note","title":"Note","text":"<p>It is not necessary to login into Sankaku Complex at all. You are free to send requests to server as unauthorized user, but in that case some methods will be unavailable to you (e.g. <code>get_favorited_posts()</code>, <code>get_favorited_books()</code> etc.).</p>"},{"location":"authorization/#authorization-via-access-token","title":"Authorization via access token","text":"<p>The following code block shows how to login into account using access token:</p> <pre><code>import asyncio\nimport os\nfrom sankaku import SankakuClient\nasync def main():\nclient = SankakuClient()\nawait client.login(access_token=os.getenv(\"ACCESS_TOKEN\"))\n# We're using virtual environment variables to prevent\n# private data from accidentally leaking.\n# ... Continue to work with API\nasyncio.run(main())\n</code></pre>"},{"location":"authorization/#authorization-via-credentials","title":"Authorization via credentials","text":"<p>Authorization method by credentials is the same as in previous example, but now user should pass two arguments to <code>login()</code> method:</p> <pre><code>import asyncio\nimport os\nfrom sankaku import SankakuClient\nasync def main():\nclient = SankakuClient()\nawait client.login(\nlogin=os.getenv(\"LOGIN\"), password=os.getenv(\"PASSWORD\")\n)\n# ... Continue to work with API\nasyncio.run(main())\n</code></pre>"},{"location":"authorization/#results","title":"Results","text":"<p>If authorization was successful, server will return response with serialized json data which will be processed by pydantic. After that user profile model will be passed to <code>client.profile</code> and all further requests to Sankaku servers will be performed on behalf of logged-in user.</p>"},{"location":"api/","title":"Introduction to sankaku API","text":"<p>This section describes main objects used by sankaku.</p> <p>Predefined custom type definition and constant values are excluded from this section.</p>"},{"location":"api/errors/","title":"Documentation for sankaku's errors","text":""},{"location":"api/errors/#sankaku.errors.SankakuError","title":"<code>sankaku.errors.SankakuError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Base error class for raising exceptions without any special params.</p> Source code in <code>sankaku/errors.py</code> <pre><code>class SankakuError(Exception):\n\"\"\"Base error class for raising exceptions without any special params.\"\"\"\nmsg: str = \"\"\ndef __init__(self, msg: Optional[str] = None) -&gt; None:\nself.msg = msg or self.msg\ndef __repr__(self) -&gt; str:\nreturn repr(self.msg)\ndef __str__(self) -&gt; str:\nreturn str(self.msg)\n</code></pre>"},{"location":"api/errors/#sankaku.errors.SankakuError.__init__","title":"<code>__init__(msg=None)</code>","text":"Source code in <code>sankaku/errors.py</code> <pre><code>def __init__(self, msg: Optional[str] = None) -&gt; None:\nself.msg = msg or self.msg\n</code></pre>"},{"location":"api/errors/#sankaku.errors.RateLimitError","title":"<code>sankaku.errors.RateLimitError</code>","text":"<p>         Bases: <code>SankakuError</code></p> Source code in <code>sankaku/errors.py</code> <pre><code>class RateLimitError(SankakuError):\nmsg = \"Can't set both rps and rpm at once.\"\n</code></pre>"},{"location":"api/errors/#sankaku.errors.LoginRequirementError","title":"<code>sankaku.errors.LoginRequirementError</code>","text":"<p>         Bases: <code>SankakuError</code></p> Source code in <code>sankaku/errors.py</code> <pre><code>class LoginRequirementError(SankakuError):\nmsg = \"You must be logged-in.\"\n</code></pre>"},{"location":"api/errors/#sankaku.errors.VideoDurationError","title":"<code>sankaku.errors.VideoDurationError</code>","text":"<p>         Bases: <code>SankakuError</code></p> Source code in <code>sankaku/errors.py</code> <pre><code>class VideoDurationError(SankakuError):\nmsg = \"Argument is available only with video files.\"\n</code></pre>"},{"location":"api/errors/#sankaku.errors.SankakuServerError","title":"<code>sankaku.errors.SankakuServerError</code>","text":"<p>         Bases: <code>SankakuError</code></p> <p>Error class for parametrized exceptions.</p> Source code in <code>sankaku/errors.py</code> <pre><code>class SankakuServerError(SankakuError):\n\"\"\"Error class for parametrized exceptions.\"\"\"\ndef __init__(\nself,\nstatus: Optional[int],\nmsg: Optional[str] = None,\n**kwargs\n) -&gt; None:\nself.status = status\nself.kwargs = kwargs\nstr_kwargs = \", \".join(f\"{k}={v}\" for k, v in self.kwargs.items())\ndelimiter = \": \" if self.kwargs else \"\"\nself.msg = f\"[{self.status}] {msg or self.msg}{delimiter}{str_kwargs}.\"\ndef __repr__(self) -&gt; str:\nreturn repr(self.msg)\ndef __str__(self) -&gt; str:\nreturn str(self.msg)\n</code></pre>"},{"location":"api/errors/#sankaku.errors.SankakuServerError.__init__","title":"<code>__init__(status, msg=None, **kwargs)</code>","text":"Source code in <code>sankaku/errors.py</code> <pre><code>def __init__(\nself,\nstatus: Optional[int],\nmsg: Optional[str] = None,\n**kwargs\n) -&gt; None:\nself.status = status\nself.kwargs = kwargs\nstr_kwargs = \", \".join(f\"{k}={v}\" for k, v in self.kwargs.items())\ndelimiter = \": \" if self.kwargs else \"\"\nself.msg = f\"[{self.status}] {msg or self.msg}{delimiter}{str_kwargs}.\"\n</code></pre>"},{"location":"api/errors/#sankaku.errors.PaginatorLastPage","title":"<code>sankaku.errors.PaginatorLastPage</code>","text":"<p>         Bases: <code>SankakuServerError</code></p> Source code in <code>sankaku/errors.py</code> <pre><code>class PaginatorLastPage(SankakuServerError):\nmsg = \"Last available page reached\"\n</code></pre>"},{"location":"api/errors/#sankaku.errors.PageNotFoundError","title":"<code>sankaku.errors.PageNotFoundError</code>","text":"<p>         Bases: <code>SankakuServerError</code></p> Source code in <code>sankaku/errors.py</code> <pre><code>class PageNotFoundError(SankakuServerError):\nmsg = f\"Failed to fetch page with requested params\"\n</code></pre>"},{"location":"api/errors/#sankaku.errors.AuthorizationError","title":"<code>sankaku.errors.AuthorizationError</code>","text":"<p>         Bases: <code>SankakuServerError</code></p> Source code in <code>sankaku/errors.py</code> <pre><code>class AuthorizationError(SankakuServerError):\nmsg = f\"Authorization failed\"\n</code></pre>"},{"location":"api/types/","title":"Documentation for sankaku's <code>enum</code> types","text":""},{"location":"api/types/#sankaku.types.Rating","title":"<code>sankaku.types.Rating</code>","text":"<p>         Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/types/#sankaku.types.Rating.SAFE","title":"<code>SAFE = 's'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.Rating.QUESTIONABLE","title":"<code>QUESTIONABLE = 'q'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.Rating.EXPLICIT","title":"<code>EXPLICIT = 'e'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.PostOrder","title":"<code>sankaku.types.PostOrder</code>","text":"<p>         Bases: <code>Enum</code></p>"},{"location":"api/types/#sankaku.types.PostOrder.POPULARITY","title":"<code>POPULARITY = 'popularity'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.PostOrder.DATE","title":"<code>DATE = 'date'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.PostOrder.QUALITY","title":"<code>QUALITY = 'quality'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.PostOrder.RANDOM","title":"<code>RANDOM = 'random'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.PostOrder.RECENTLY_FAVORITED","title":"<code>RECENTLY_FAVORITED = 'recently_favorited'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.PostOrder.RECENTLY_VOTED","title":"<code>RECENTLY_VOTED = 'recently_voted'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.SortParameter","title":"<code>sankaku.types.SortParameter</code>","text":"<p>         Bases: <code>Enum</code></p>"},{"location":"api/types/#sankaku.types.SortParameter.NAME","title":"<code>NAME = 'name'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.SortParameter.TRANSLATIONS","title":"<code>TRANSLATIONS = 'name_ja'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.SortParameter.TYPE","title":"<code>TYPE = 'type'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.SortParameter.RATING","title":"<code>RATING = 'rating'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.SortParameter.BOOK_COUNT","title":"<code>BOOK_COUNT = 'pool_count'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.SortParameter.POST_COUNT","title":"<code>POST_COUNT = 'count'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.SortDirection","title":"<code>sankaku.types.SortDirection</code>","text":"<p>         Bases: <code>Enum</code></p>"},{"location":"api/types/#sankaku.types.SortDirection.ASC","title":"<code>ASC = 'asc'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.SortDirection.DESC","title":"<code>DESC = 'desc'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.TagOrder","title":"<code>sankaku.types.TagOrder</code>","text":"<p>         Bases: <code>Enum</code></p>"},{"location":"api/types/#sankaku.types.TagOrder.POPULARITY","title":"<code>POPULARITY = 'popularity'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.TagOrder.QUALITY","title":"<code>QUALITY = 'quality'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.TagType","title":"<code>sankaku.types.TagType</code>","text":"<p>         Bases: <code>Enum</code></p>"},{"location":"api/types/#sankaku.types.TagType.ARTIST","title":"<code>ARTIST = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.TagType.COPYRIGHT","title":"<code>COPYRIGHT = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.TagType.CHARACTER","title":"<code>CHARACTER = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.TagType.MEDIUM","title":"<code>MEDIUM = 8</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.TagType.META","title":"<code>META = 9</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.TagType.GENRE","title":"<code>GENRE = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.TagType.STUDIO","title":"<code>STUDIO = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.FileType","title":"<code>sankaku.types.FileType</code>","text":"<p>         Bases: <code>Enum</code></p>"},{"location":"api/types/#sankaku.types.FileType.IMAGE","title":"<code>IMAGE = 'image'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.FileType.GIF","title":"<code>GIF = 'animated_gif'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.FileType.VIDEO","title":"<code>VIDEO = 'video'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.FileSize","title":"<code>sankaku.types.FileSize</code>","text":"<p>         Bases: <code>Enum</code></p>"},{"location":"api/types/#sankaku.types.FileSize.LARGE","title":"<code>LARGE = 'large_filesize'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.FileSize.HUGE","title":"<code>HUGE = 'extremely_large_filesize'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.FileSize.LONG","title":"<code>LONG = 'long_image'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.FileSize.WALLPAPER","title":"<code>WALLPAPER = 'wallpaper'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.FileSize.A_RATIO_16_9","title":"<code>A_RATIO_16_9 = '16:9_aspect_ratio'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.FileSize.A_RATIO_4_3","title":"<code>A_RATIO_4_3 = '4:3_aspect_ratio'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.FileSize.A_RATIO_3_2","title":"<code>A_RATIO_3_2 = '3:2_aspect_ratio'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.FileSize.A_RATIO_1_1","title":"<code>A_RATIO_1_1 = '1:1_aspect_ratio'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.UserOrder","title":"<code>sankaku.types.UserOrder</code>","text":"<p>         Bases: <code>Enum</code></p>"},{"location":"api/types/#sankaku.types.UserOrder.POSTS","title":"<code>POSTS = 'post_upload_count'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.UserOrder.FAVORITES","title":"<code>FAVORITES = 'favorite_count'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.UserOrder.NAME","title":"<code>NAME = 'name'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.UserOrder.NEWEST","title":"<code>NEWEST = 'newest'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.UserOrder.OLDEST","title":"<code>OLDEST = 'oldest'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.UserOrder.LAST_SEEN","title":"<code>LAST_SEEN = 'active'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.UserLevel","title":"<code>sankaku.types.UserLevel</code>","text":"<p>         Bases: <code>Enum</code></p>"},{"location":"api/types/#sankaku.types.UserLevel.ADMIN","title":"<code>ADMIN = 50</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.UserLevel.SYSTEM_USER","title":"<code>SYSTEM_USER = 45</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.UserLevel.MODERATOR","title":"<code>MODERATOR = 40</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.UserLevel.JANITOR","title":"<code>JANITOR = 35</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.UserLevel.CONTRIBUTOR","title":"<code>CONTRIBUTOR = 33</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.UserLevel.PRIVILEGED","title":"<code>PRIVILEGED = 30</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.UserLevel.MEMBER","title":"<code>MEMBER = 20</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.UserLevel.BLOCKED","title":"<code>BLOCKED = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.UserLevel.UNACTIVATED","title":"<code>UNACTIVATED = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.BookOrder","title":"<code>sankaku.types.BookOrder</code>","text":"<p>         Bases: <code>Enum</code></p>"},{"location":"api/types/#sankaku.types.BookOrder.DATE","title":"<code>DATE = 'date'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.BookOrder.QUALITY","title":"<code>QUALITY = 'quality'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.BookOrder.RANDOM","title":"<code>RANDOM = 'random'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.BookOrder.RECENTLY_FAVORITED","title":"<code>RECENTLY_FAVORITED = 'recently_favorited'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#sankaku.types.BookOrder.RECENTLY_VOTED","title":"<code>RECENTLY_VOTED = 'recently_voted'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/utils/","title":"Documentation for miscellaneous support functions","text":""},{"location":"api/utils/#sankaku.utils.ratelimit","title":"<code>sankaku.utils.ratelimit(*, rps=None, rpm=None)</code>","text":"<p>Limit the number of requests.</p> <p>Parameters:</p> Name Type Description Default <code>rps</code> <code>Optional[int]</code> <p>Request per second</p> <code>None</code> <code>rpm</code> <code>Optional[int]</code> <p>Requests per minute</p> <code>None</code> Source code in <code>sankaku/utils.py</code> <pre><code>def ratelimit(\n*,\nrps: Optional[int] = None,\nrpm: Optional[int] = None\n) -&gt; Callable[[Callable[_P, Awaitable[_T]]], Callable[_P, Awaitable[_T]]]:\n\"\"\"Limit the number of requests.\n    Args:\n        rps: Request per second\n        rpm: Requests per minute\n    \"\"\"\nif all(locals().values()):\nraise RateLimitError\nelif not any(locals().values()):\nraise TypeError(\"At least one argument must be specified.\")\nsleep_time: float = (1 / rps) if rps else (60 / rpm)  # type: ignore[operator]\ndef wrapper(func: Callable[_P, Awaitable[_T]]) -&gt; Callable[_P, Awaitable[_T]]:\n@wraps(func)\nasync def inner(*args: _P.args, **kwargs: _P.kwargs) -&gt; _T:\nawait asyncio.sleep(sleep_time)\nreturn await func(*args, **kwargs)  # noqa\nreturn inner\nreturn wrapper\n</code></pre>"},{"location":"api/utils/#sankaku.utils.convert_ts_to_datetime","title":"<code>sankaku.utils.convert_ts_to_datetime(ts)</code>","text":"<p>Convert timestamp in datetime dict into datetime class.</p> Source code in <code>sankaku/utils.py</code> <pre><code>def convert_ts_to_datetime(ts: Timestamp) -&gt; Optional[datetime]:\n\"\"\"Convert timestamp in datetime dict into datetime class.\"\"\"\nif ts.get(\"s\") is None:\nreturn None\nreturn datetime.utcfromtimestamp(ts[\"s\"]).astimezone()  # type: ignore[arg-type]\n</code></pre>"},{"location":"api/utils/#sankaku.utils.from_locals","title":"<code>sankaku.utils.from_locals(loc, exclude=('self'))</code>","text":"<p>Get arguments of calling function from its locals to pass them to paginator.</p> <p>Parameters:</p> Name Type Description Default <code>loc</code> <code>Dict[str, Any]</code> <p>locals of calling function</p> required <code>exclude</code> <code>Tuple[str, ...]</code> <p>arguments to be excluded</p> <code>('self')</code> Source code in <code>sankaku/utils.py</code> <pre><code>def from_locals(\nloc: Dict[str, Any], exclude: Tuple[str, ...] = (\"self\",)\n) -&gt; Dict[str, Any]:\n\"\"\"Get arguments of calling function from its locals to pass them to paginator.\n    Args:\n        loc: locals of calling function\n        exclude: arguments to be excluded\n    \"\"\"\nreturn {k: v for k, v in loc.copy().items() if k not in exclude}\n</code></pre>"},{"location":"api/clients/abc/","title":"Documentation for <code>abc.py</code>","text":""},{"location":"api/clients/abc/#sankaku.clients.abc.ABCHttpClient","title":"<code>sankaku.clients.abc.ABCHttpClient</code>","text":"<p>         Bases: <code>ABC</code></p> <p>Abstract client for handling http requests.</p> Source code in <code>sankaku/clients/abc.py</code> <pre><code>class ABCHttpClient(ABC):\n\"\"\"Abstract client for handling http requests.\"\"\"\n@abstractmethod\ndef __init__(self, *args, **kwargs) -&gt; None:\npass\nasync def __aenter__(self):\nreturn self\nasync def __aexit__(self, exc_type, exc_val, exc_tb) -&gt; None:\nawait self.close()\n@abstractmethod\ndef __del__(self) -&gt; None:\npass\n@abstractmethod\nasync def close(self) -&gt; None:\n\"\"\"Close previously created client session.\"\"\"\n@abstractmethod\nasync def request(self, method: str, url: str, **kwargs) -&gt; ClientResponse:\n\"\"\"Make request to specified url.\"\"\"\n</code></pre>"},{"location":"api/clients/abc/#sankaku.clients.abc.ABCHttpClient.close","title":"<code>close()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Close previously created client session.</p> Source code in <code>sankaku/clients/abc.py</code> <pre><code>@abstractmethod\nasync def close(self) -&gt; None:\n\"\"\"Close previously created client session.\"\"\"\n</code></pre>"},{"location":"api/clients/abc/#sankaku.clients.abc.ABCHttpClient.request","title":"<code>request(method, url, **kwargs)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Make request to specified url.</p> Source code in <code>sankaku/clients/abc.py</code> <pre><code>@abstractmethod\nasync def request(self, method: str, url: str, **kwargs) -&gt; ClientResponse:\n\"\"\"Make request to specified url.\"\"\"\n</code></pre>"},{"location":"api/clients/abc/#sankaku.clients.abc.ABCClient","title":"<code>sankaku.clients.abc.ABCClient</code>","text":"<p>         Bases: <code>ABC</code></p> <p>Abstract Sankaku client.</p> Source code in <code>sankaku/clients/abc.py</code> <pre><code>class ABCClient(ABC):\n\"\"\"Abstract Sankaku client.\"\"\"\n@abstractmethod\ndef __init__(self, *args, **kwargs) -&gt; None:\npass\n@abstractmethod\nasync def login(\nself,\n*,\naccess_token: Optional[str] = None,\nlogin: Optional[str] = None,\npassword: Optional[str] = None\n) -&gt; None:\n\"\"\"Login into sankakucomplex.com via access token or credentials.\"\"\"\n</code></pre>"},{"location":"api/clients/abc/#sankaku.clients.abc.ABCClient.login","title":"<code>login(*, access_token=None, login=None, password=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Login into sankakucomplex.com via access token or credentials.</p> Source code in <code>sankaku/clients/abc.py</code> <pre><code>@abstractmethod\nasync def login(\nself,\n*,\naccess_token: Optional[str] = None,\nlogin: Optional[str] = None,\npassword: Optional[str] = None\n) -&gt; None:\n\"\"\"Login into sankakucomplex.com via access token or credentials.\"\"\"\n</code></pre>"},{"location":"api/clients/clients/","title":"Documentation for <code>clients.py</code>","text":""},{"location":"api/clients/clients/#sankaku.clients.clients.BaseClient","title":"<code>sankaku.clients.clients.BaseClient</code>","text":"<p>         Bases: <code>ABCClient</code></p> <p>Base client used for login.</p> Source code in <code>sankaku/clients/clients.py</code> <pre><code>class BaseClient(ABCClient):\n\"\"\"Base client used for login.\"\"\"\ndef __init__(self) -&gt; None:\nself._profile: Optional[mdl.ExtendedUser] = None\nself._http_client: HttpClient = HttpClient()\nself._access_token: Optional[str] = None  # TODO: ability to update access token\nself._token_type: Optional[str] = None\nasync def _login_via_credentials(self, login: str, password: str) -&gt; None:\nresponse = await self._http_client.post(\nconst.LOGIN_URL,\ndata=json.dumps({\"login\": login, \"password\": password})\n)\nif not response.ok:\nraise errors.AuthorizationError(response.status, **response.json)\nself._access_token = response.json[\"access_token\"]\nself._token_type = response.json[\"token_type\"]\nself._profile = mdl.ExtendedUser(**response.json[\"current_user\"])\nasync def _login_via_access_token(self, access_token: str) -&gt; None:\ntry:\nself._profile = await self._get_profile(access_token)\n# Update access token and token type after successful profile fetch\nself._access_token = access_token\nself._token_type = const.DEFAULT_TOKEN_TYPE\nexcept errors.SankakuServerError as e:\nraise errors.AuthorizationError(e.status, **e.kwargs)\nasync def _get_profile(self, access_token: str) -&gt; mdl.ExtendedUser:\n\"\"\"Get user profile information from Sankaku server by access token.\"\"\"\nif self._profile is not None:\nreturn self._profile\nheaders = {\"authorization\": f\"{const.DEFAULT_TOKEN_TYPE} {access_token}\"}\nheaders.update(self._http_client.headers)\nresponse = await self._http_client.get(f\"{const.PROFILE_URL}\", headers=headers)\nif not response.ok:\nraise errors.SankakuServerError(\nresponse.status, \"Failed to get user profile\", **response.json\n)\nreturn mdl.ExtendedUser(**response.json[\"user\"])\nasync def login(\nself,\n*,\naccess_token: Optional[str] = None,\nlogin: Optional[str] = None,\npassword: Optional[str] = None\n) -&gt; None:\n\"\"\"Login into sankakucomplex.com via access token or credentials.\n        In case when all arguments are specified, preference will be given\n        to authorization by credentials.\n        Args:\n            access_token: User access token\n            login: User email or nickname\n            password: User password\n        \"\"\"\nif login and password:\nawait self._login_via_credentials(login, password)  # type: ignore[arg-type]\nelif access_token and not login and not password:\nawait self._login_via_access_token(access_token)  # type: ignore[arg-type]\nelse:\nraise errors.SankakuError(\n\"The given data is not enough \"\n\"or invalid (perhaps of the wrong type).\"\n)\nself._http_client.headers.update(\nauthorization=f\"{self._token_type} {self._access_token}\"\n)\nlogger.info(f\"Successfully logged in as {self._profile.name}.\")  # type: ignore[union-attr]\n@property\ndef profile(self) -&gt; Optional[mdl.ExtendedUser]:\nreturn self._profile\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.BaseClient.login","title":"<code>login(*, access_token=None, login=None, password=None)</code>  <code>async</code>","text":"<p>Login into sankakucomplex.com via access token or credentials. In case when all arguments are specified, preference will be given to authorization by credentials.</p> <p>Parameters:</p> Name Type Description Default <code>access_token</code> <code>Optional[str]</code> <p>User access token</p> <code>None</code> <code>login</code> <code>Optional[str]</code> <p>User email or nickname</p> <code>None</code> <code>password</code> <code>Optional[str]</code> <p>User password</p> <code>None</code> Source code in <code>sankaku/clients/clients.py</code> <pre><code>async def login(\nself,\n*,\naccess_token: Optional[str] = None,\nlogin: Optional[str] = None,\npassword: Optional[str] = None\n) -&gt; None:\n\"\"\"Login into sankakucomplex.com via access token or credentials.\n    In case when all arguments are specified, preference will be given\n    to authorization by credentials.\n    Args:\n        access_token: User access token\n        login: User email or nickname\n        password: User password\n    \"\"\"\nif login and password:\nawait self._login_via_credentials(login, password)  # type: ignore[arg-type]\nelif access_token and not login and not password:\nawait self._login_via_access_token(access_token)  # type: ignore[arg-type]\nelse:\nraise errors.SankakuError(\n\"The given data is not enough \"\n\"or invalid (perhaps of the wrong type).\"\n)\nself._http_client.headers.update(\nauthorization=f\"{self._token_type} {self._access_token}\"\n)\nlogger.info(f\"Successfully logged in as {self._profile.name}.\")  # type: ignore[union-attr]\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.PostClient","title":"<code>sankaku.clients.clients.PostClient</code>","text":"<p>         Bases: <code>BaseClient</code></p> <p>Client for post browsing.</p> Source code in <code>sankaku/clients/clients.py</code> <pre><code>class PostClient(BaseClient):\n\"\"\"Client for post browsing.\"\"\"\nasync def browse_posts(\nself,\norder: Optional[types.PostOrder] = None,\ndate: Optional[List[datetime]] = None,\nrating: Optional[types.Rating] = None,\nthreshold: Optional[Annotated[int, ValueRange(1, 100)]] = None,\nhide_posts_in_books: Optional[Literal[\"in-larger-tags\", \"always\"]] = None,\nfile_size: Optional[types.FileSize] = None,\nfile_type: Optional[types.FileType] = None,\nvideo_duration: Optional[List[int]] = None,\nrecommended_for: Optional[str] = None,\nfavorited_by: Optional[str] = None,\ntags: Optional[List[str]] = None,\nadded_by: Optional[List[str]] = None,\nvoted: Optional[str] = None,\n*,\npage_number: Optional[int] = None,\nlimit: Optional[Annotated[int, ValueRange(1, 100)]] = None\n) -&gt; AsyncIterator[mdl.Post]:\n\"\"\"Get posts from post pages.\n        Args:\n            order: Post order rule\n            date: Date or range of dates\n            rating: Post rating\n            threshold: Vote (quality) filter of posts\n            hide_posts_in_books: Whether show post from books or not\n            file_size: Size (aspect ratio) of mediafile\n            file_type: Type of mediafile in post\n            video_duration: Video duration in seconds or in range of seconds\n            recommended_for: Posts recommended for specified user\n            favorited_by: Posts favorited by specified user\n            tags: Tags available for search\n            added_by: Posts uploaded by specified users\n            voted: Posts voted by specified user\n            page_number: Page number from which to start iteration\n            limit: Maximum amount of posts per page\n        \"\"\"\nasync for page in PostPaginator(\nself._http_client, const.POST_URL, **from_locals(locals())\n):\nfor post in page.items:\nyield post\nasync def get_favorited_posts(self) -&gt; AsyncIterator[mdl.Post]:\n\"\"\"Shorthand way to get favorited posts of currently logged-in user.\"\"\"\nif self._profile is None:\nraise errors.LoginRequirementError\nasync for post in self.browse_posts(favorited_by=self._profile.name):\nyield post\nasync def get_top_posts(self) -&gt; AsyncIterator[mdl.Post]:\n\"\"\"Shorthand way to get top posts.\"\"\"\nasync for post in self.browse_posts(order=types.PostOrder.QUALITY):\nyield post\nasync def get_popular_posts(self) -&gt; AsyncIterator[mdl.Post]:\n\"\"\"Shorthand way to get popular posts.\"\"\"\nasync for post in self.browse_posts(order=types.PostOrder.POPULARITY):\nyield post\nasync def get_recommended_posts(self) -&gt; AsyncIterator[mdl.Post]:\n\"\"\"Shorthand way to get recommended posts for the currently logged-in user.\"\"\"\nif self._profile is None:\nraise errors.LoginRequirementError\nasync for post in self.browse_posts(recommended_for=self._profile.name):\nyield post\nasync def get_similar_posts(self, post_id: int) -&gt; AsyncIterator[mdl.Post]:\n\"\"\"Get posts similar (recommended) for specific post by its ID.\"\"\"\ntag = f\"recommended_for_post:{post_id}\"\nasync for post in self.browse_posts(tags=[tag]):\nyield post\nasync def get_post_comments(self, post_id: int) -&gt; AsyncIterator[mdl.Comment]:\n\"\"\"Get comments of the specific post by its ID.\"\"\"\nasync for page in Paginator(\nself._http_client,\nconst.COMMENT_URL.format(post_id=post_id),\nmdl.Comment\n):\nfor comment in page.items:\nyield comment\nasync def get_post(self, post_id: int) -&gt; mdl.Post:\n\"\"\"Get specific post by its ID.\"\"\"\nresponse = await self._http_client.get(f\"{const.POST_URL}/{post_id}\")\nif not response.ok:\nraise errors.PageNotFoundError(response.status, post_id=post_id)\nreturn mdl.Post(**response.json)\nasync def create_post(self):  # TODO: TBA\nraise NotImplementedError\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.PostClient.browse_posts","title":"<code>browse_posts(order=None, date=None, rating=None, threshold=None, hide_posts_in_books=None, file_size=None, file_type=None, video_duration=None, recommended_for=None, favorited_by=None, tags=None, added_by=None, voted=None, *, page_number=None, limit=None)</code>  <code>async</code>","text":"<p>Get posts from post pages.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>Optional[types.PostOrder]</code> <p>Post order rule</p> <code>None</code> <code>date</code> <code>Optional[List[datetime]]</code> <p>Date or range of dates</p> <code>None</code> <code>rating</code> <code>Optional[types.Rating]</code> <p>Post rating</p> <code>None</code> <code>threshold</code> <code>Optional[Annotated[int, ValueRange(1, 100)]]</code> <p>Vote (quality) filter of posts</p> <code>None</code> <code>hide_posts_in_books</code> <code>Optional[Literal['in-larger-tags', 'always']]</code> <p>Whether show post from books or not</p> <code>None</code> <code>file_size</code> <code>Optional[types.FileSize]</code> <p>Size (aspect ratio) of mediafile</p> <code>None</code> <code>file_type</code> <code>Optional[types.FileType]</code> <p>Type of mediafile in post</p> <code>None</code> <code>video_duration</code> <code>Optional[List[int]]</code> <p>Video duration in seconds or in range of seconds</p> <code>None</code> <code>recommended_for</code> <code>Optional[str]</code> <p>Posts recommended for specified user</p> <code>None</code> <code>favorited_by</code> <code>Optional[str]</code> <p>Posts favorited by specified user</p> <code>None</code> <code>tags</code> <code>Optional[List[str]]</code> <p>Tags available for search</p> <code>None</code> <code>added_by</code> <code>Optional[List[str]]</code> <p>Posts uploaded by specified users</p> <code>None</code> <code>voted</code> <code>Optional[str]</code> <p>Posts voted by specified user</p> <code>None</code> <code>page_number</code> <code>Optional[int]</code> <p>Page number from which to start iteration</p> <code>None</code> <code>limit</code> <code>Optional[Annotated[int, ValueRange(1, 100)]]</code> <p>Maximum amount of posts per page</p> <code>None</code> Source code in <code>sankaku/clients/clients.py</code> <pre><code>async def browse_posts(\nself,\norder: Optional[types.PostOrder] = None,\ndate: Optional[List[datetime]] = None,\nrating: Optional[types.Rating] = None,\nthreshold: Optional[Annotated[int, ValueRange(1, 100)]] = None,\nhide_posts_in_books: Optional[Literal[\"in-larger-tags\", \"always\"]] = None,\nfile_size: Optional[types.FileSize] = None,\nfile_type: Optional[types.FileType] = None,\nvideo_duration: Optional[List[int]] = None,\nrecommended_for: Optional[str] = None,\nfavorited_by: Optional[str] = None,\ntags: Optional[List[str]] = None,\nadded_by: Optional[List[str]] = None,\nvoted: Optional[str] = None,\n*,\npage_number: Optional[int] = None,\nlimit: Optional[Annotated[int, ValueRange(1, 100)]] = None\n) -&gt; AsyncIterator[mdl.Post]:\n\"\"\"Get posts from post pages.\n    Args:\n        order: Post order rule\n        date: Date or range of dates\n        rating: Post rating\n        threshold: Vote (quality) filter of posts\n        hide_posts_in_books: Whether show post from books or not\n        file_size: Size (aspect ratio) of mediafile\n        file_type: Type of mediafile in post\n        video_duration: Video duration in seconds or in range of seconds\n        recommended_for: Posts recommended for specified user\n        favorited_by: Posts favorited by specified user\n        tags: Tags available for search\n        added_by: Posts uploaded by specified users\n        voted: Posts voted by specified user\n        page_number: Page number from which to start iteration\n        limit: Maximum amount of posts per page\n    \"\"\"\nasync for page in PostPaginator(\nself._http_client, const.POST_URL, **from_locals(locals())\n):\nfor post in page.items:\nyield post\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.PostClient.get_favorited_posts","title":"<code>get_favorited_posts()</code>  <code>async</code>","text":"<p>Shorthand way to get favorited posts of currently logged-in user.</p> Source code in <code>sankaku/clients/clients.py</code> <pre><code>async def get_favorited_posts(self) -&gt; AsyncIterator[mdl.Post]:\n\"\"\"Shorthand way to get favorited posts of currently logged-in user.\"\"\"\nif self._profile is None:\nraise errors.LoginRequirementError\nasync for post in self.browse_posts(favorited_by=self._profile.name):\nyield post\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.PostClient.get_top_posts","title":"<code>get_top_posts()</code>  <code>async</code>","text":"<p>Shorthand way to get top posts.</p> Source code in <code>sankaku/clients/clients.py</code> <pre><code>async def get_top_posts(self) -&gt; AsyncIterator[mdl.Post]:\n\"\"\"Shorthand way to get top posts.\"\"\"\nasync for post in self.browse_posts(order=types.PostOrder.QUALITY):\nyield post\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.PostClient.get_popular_posts","title":"<code>get_popular_posts()</code>  <code>async</code>","text":"<p>Shorthand way to get popular posts.</p> Source code in <code>sankaku/clients/clients.py</code> <pre><code>async def get_popular_posts(self) -&gt; AsyncIterator[mdl.Post]:\n\"\"\"Shorthand way to get popular posts.\"\"\"\nasync for post in self.browse_posts(order=types.PostOrder.POPULARITY):\nyield post\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.PostClient.get_recommended_posts","title":"<code>get_recommended_posts()</code>  <code>async</code>","text":"<p>Shorthand way to get recommended posts for the currently logged-in user.</p> Source code in <code>sankaku/clients/clients.py</code> <pre><code>async def get_recommended_posts(self) -&gt; AsyncIterator[mdl.Post]:\n\"\"\"Shorthand way to get recommended posts for the currently logged-in user.\"\"\"\nif self._profile is None:\nraise errors.LoginRequirementError\nasync for post in self.browse_posts(recommended_for=self._profile.name):\nyield post\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.PostClient.get_similar_posts","title":"<code>get_similar_posts(post_id)</code>  <code>async</code>","text":"<p>Get posts similar (recommended) for specific post by its ID.</p> Source code in <code>sankaku/clients/clients.py</code> <pre><code>async def get_similar_posts(self, post_id: int) -&gt; AsyncIterator[mdl.Post]:\n\"\"\"Get posts similar (recommended) for specific post by its ID.\"\"\"\ntag = f\"recommended_for_post:{post_id}\"\nasync for post in self.browse_posts(tags=[tag]):\nyield post\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.PostClient.get_post_comments","title":"<code>get_post_comments(post_id)</code>  <code>async</code>","text":"<p>Get comments of the specific post by its ID.</p> Source code in <code>sankaku/clients/clients.py</code> <pre><code>async def get_post_comments(self, post_id: int) -&gt; AsyncIterator[mdl.Comment]:\n\"\"\"Get comments of the specific post by its ID.\"\"\"\nasync for page in Paginator(\nself._http_client,\nconst.COMMENT_URL.format(post_id=post_id),\nmdl.Comment\n):\nfor comment in page.items:\nyield comment\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.PostClient.get_post","title":"<code>get_post(post_id)</code>  <code>async</code>","text":"<p>Get specific post by its ID.</p> Source code in <code>sankaku/clients/clients.py</code> <pre><code>async def get_post(self, post_id: int) -&gt; mdl.Post:\n\"\"\"Get specific post by its ID.\"\"\"\nresponse = await self._http_client.get(f\"{const.POST_URL}/{post_id}\")\nif not response.ok:\nraise errors.PageNotFoundError(response.status, post_id=post_id)\nreturn mdl.Post(**response.json)\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.AIClient","title":"<code>sankaku.clients.clients.AIClient</code>","text":"<p>         Bases: <code>BaseClient</code></p> <p>Client for working with Sankaku built-in AI.</p> Source code in <code>sankaku/clients/clients.py</code> <pre><code>class AIClient(BaseClient):\n\"\"\"Client for working with Sankaku built-in AI.\"\"\"\nasync def browse_ai_posts(\nself,\n*,\npage_number: Optional[int] = None,\nlimit: Optional[Annotated[int, ValueRange(1, 100)]] = None\n) -&gt; AsyncIterator[mdl.AIPost]:\n\"\"\"Get AI created posts from AI dedicated post pages.\n        Args:\n            page_number: Page number from which to start iteration\n            limit: Maximum amount of posts per page\n        \"\"\"\nasync for page in Paginator(\nself._http_client, const.AI_POST_URL,\nmdl.AIPost, **from_locals(locals())\n):\nfor post in page.items:\nyield post\nasync def get_ai_post(self, post_id: int) -&gt; mdl.AIPost:\n\"\"\"Get specific AI post by its ID.\"\"\"\nresponse = await self._http_client.get(f\"{const.AI_POST_URL}/{post_id}\")\nif not response.ok:\nraise errors.PageNotFoundError(response.status, post_id=post_id)\nreturn mdl.AIPost(**response.json)\nasync def create_ai_post(self):  # TODO: TBA\nraise NotImplementedError\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.AIClient.browse_ai_posts","title":"<code>browse_ai_posts(*, page_number=None, limit=None)</code>  <code>async</code>","text":"<p>Get AI created posts from AI dedicated post pages.</p> <p>Parameters:</p> Name Type Description Default <code>page_number</code> <code>Optional[int]</code> <p>Page number from which to start iteration</p> <code>None</code> <code>limit</code> <code>Optional[Annotated[int, ValueRange(1, 100)]]</code> <p>Maximum amount of posts per page</p> <code>None</code> Source code in <code>sankaku/clients/clients.py</code> <pre><code>async def browse_ai_posts(\nself,\n*,\npage_number: Optional[int] = None,\nlimit: Optional[Annotated[int, ValueRange(1, 100)]] = None\n) -&gt; AsyncIterator[mdl.AIPost]:\n\"\"\"Get AI created posts from AI dedicated post pages.\n    Args:\n        page_number: Page number from which to start iteration\n        limit: Maximum amount of posts per page\n    \"\"\"\nasync for page in Paginator(\nself._http_client, const.AI_POST_URL,\nmdl.AIPost, **from_locals(locals())\n):\nfor post in page.items:\nyield post\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.AIClient.get_ai_post","title":"<code>get_ai_post(post_id)</code>  <code>async</code>","text":"<p>Get specific AI post by its ID.</p> Source code in <code>sankaku/clients/clients.py</code> <pre><code>async def get_ai_post(self, post_id: int) -&gt; mdl.AIPost:\n\"\"\"Get specific AI post by its ID.\"\"\"\nresponse = await self._http_client.get(f\"{const.AI_POST_URL}/{post_id}\")\nif not response.ok:\nraise errors.PageNotFoundError(response.status, post_id=post_id)\nreturn mdl.AIPost(**response.json)\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.TagClient","title":"<code>sankaku.clients.clients.TagClient</code>","text":"<p>         Bases: <code>BaseClient</code></p> <p>Client for tag browsing.</p> Source code in <code>sankaku/clients/clients.py</code> <pre><code>class TagClient(BaseClient):\n\"\"\"Client for tag browsing.\"\"\"\nasync def browse_tags(\nself,\ntag_type: Optional[types.TagType] = None,  # TODO: ability to specify multiple tags\norder: Optional[types.TagOrder] = None,\nrating: Optional[types.Rating] = None,\nmax_post_count: Optional[int] = None,\nsort_parameter: Optional[types.SortParameter] = None,\nsort_direction: Optional[types.SortDirection] = None,\n*,\npage_number: Optional[int] = None,\nlimit: Optional[Annotated[int, ValueRange(1, 100)]] = None\n) -&gt; AsyncIterator[mdl.PageTag]:\n\"\"\"Get tags from tag pages.\n        Args:\n            tag_type: Tag type filter\n            order: Tag order rule\n            rating: Tag rating\n            max_post_count: Upper threshold for number of posts with tags found\n            sort_parameter: Tag sorting parameter\n            sort_direction: Tag sorting direction\n            page_number: Page number from which to start iteration\n            limit: Maximum amount of tags per page\n        \"\"\"\nasync for page in TagPaginator(\nself._http_client, const.TAG_URL, **from_locals(locals())\n):\nfor tag in page.items:\nyield tag\nasync def get_tag(self, name_or_id: Union[str, int]) -&gt; mdl.WikiTag:\n\"\"\"Get specific tag by its name or ID.\"\"\"\nref = \"/name\" if isinstance(name_or_id, str) else \"/id\"\nurl = f\"{const.TAG_WIKI_URL}{ref}/{name_or_id}\"\nresponse = await self._http_client.get(url)\nif not response.ok:\nraise errors.PageNotFoundError(response.status, name_or_id=name_or_id)\nreturn mdl.WikiTag(wiki=response.json[\"wiki\"], **response.json[\"tag\"])\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.TagClient.browse_tags","title":"<code>browse_tags(tag_type=None, order=None, rating=None, max_post_count=None, sort_parameter=None, sort_direction=None, *, page_number=None, limit=None)</code>  <code>async</code>","text":"<p>Get tags from tag pages.</p> <p>Parameters:</p> Name Type Description Default <code>tag_type</code> <code>Optional[types.TagType]</code> <p>Tag type filter</p> <code>None</code> <code>order</code> <code>Optional[types.TagOrder]</code> <p>Tag order rule</p> <code>None</code> <code>rating</code> <code>Optional[types.Rating]</code> <p>Tag rating</p> <code>None</code> <code>max_post_count</code> <code>Optional[int]</code> <p>Upper threshold for number of posts with tags found</p> <code>None</code> <code>sort_parameter</code> <code>Optional[types.SortParameter]</code> <p>Tag sorting parameter</p> <code>None</code> <code>sort_direction</code> <code>Optional[types.SortDirection]</code> <p>Tag sorting direction</p> <code>None</code> <code>page_number</code> <code>Optional[int]</code> <p>Page number from which to start iteration</p> <code>None</code> <code>limit</code> <code>Optional[Annotated[int, ValueRange(1, 100)]]</code> <p>Maximum amount of tags per page</p> <code>None</code> Source code in <code>sankaku/clients/clients.py</code> <pre><code>async def browse_tags(\nself,\ntag_type: Optional[types.TagType] = None,  # TODO: ability to specify multiple tags\norder: Optional[types.TagOrder] = None,\nrating: Optional[types.Rating] = None,\nmax_post_count: Optional[int] = None,\nsort_parameter: Optional[types.SortParameter] = None,\nsort_direction: Optional[types.SortDirection] = None,\n*,\npage_number: Optional[int] = None,\nlimit: Optional[Annotated[int, ValueRange(1, 100)]] = None\n) -&gt; AsyncIterator[mdl.PageTag]:\n\"\"\"Get tags from tag pages.\n    Args:\n        tag_type: Tag type filter\n        order: Tag order rule\n        rating: Tag rating\n        max_post_count: Upper threshold for number of posts with tags found\n        sort_parameter: Tag sorting parameter\n        sort_direction: Tag sorting direction\n        page_number: Page number from which to start iteration\n        limit: Maximum amount of tags per page\n    \"\"\"\nasync for page in TagPaginator(\nself._http_client, const.TAG_URL, **from_locals(locals())\n):\nfor tag in page.items:\nyield tag\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.TagClient.get_tag","title":"<code>get_tag(name_or_id)</code>  <code>async</code>","text":"<p>Get specific tag by its name or ID.</p> Source code in <code>sankaku/clients/clients.py</code> <pre><code>async def get_tag(self, name_or_id: Union[str, int]) -&gt; mdl.WikiTag:\n\"\"\"Get specific tag by its name or ID.\"\"\"\nref = \"/name\" if isinstance(name_or_id, str) else \"/id\"\nurl = f\"{const.TAG_WIKI_URL}{ref}/{name_or_id}\"\nresponse = await self._http_client.get(url)\nif not response.ok:\nraise errors.PageNotFoundError(response.status, name_or_id=name_or_id)\nreturn mdl.WikiTag(wiki=response.json[\"wiki\"], **response.json[\"tag\"])\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.BookClient","title":"<code>sankaku.clients.clients.BookClient</code>","text":"<p>         Bases: <code>BaseClient</code></p> <p>Client for book (pool) browsing.</p> Source code in <code>sankaku/clients/clients.py</code> <pre><code>class BookClient(BaseClient):\n\"\"\"Client for book (pool) browsing.\"\"\"\nasync def browse_books(\nself,\norder: Optional[types.BookOrder] = None,\nrating: Optional[types.Rating] = None,\nrecommended_for: Optional[str] = None,\nfavorited_by: Optional[str] = None,\ntags: Optional[List[str]] = None,\nadded_by: Optional[List[str]] = None,\nvoted: Optional[str] = None,\n*,\npage_number: Optional[int] = None,\nlimit: Optional[Annotated[int, ValueRange(1, 100)]] = None\n) -&gt; AsyncIterator[mdl.PageBook]:\n\"\"\"Get books from book (pool) pages.\n        Args:\n            order: Book order rule\n            rating: Books rating\n            recommended_for: Books recommended for specified user\n            favorited_by: Books favorited by specified user\n            tags: Tags available for search\n            added_by: Books uploaded by specified users\n            voted: Books voted by specified user\n            page_number: Page number from which to start iteration\n            limit: Maximum amount of books per page\n        \"\"\"\nasync for page in BookPaginator(\nself._http_client, const.BOOK_URL, **from_locals(locals())\n):\nfor book in page.items:\nyield book\nasync def get_favorited_books(self) -&gt; AsyncIterator[mdl.PageBook]:\n\"\"\"Shorthand way to get favorited books for the currently logged-in user.\"\"\"\nif self._profile is None:\nraise errors.LoginRequirementError\nasync for book in self.browse_books(favorited_by=self._profile.name):\nyield book\nasync def get_recommended_books(self) -&gt; AsyncIterator[mdl.PageBook]:\n\"\"\"Shorthand way to get recommended books for the currently logged-in user.\"\"\"\nif self._profile is None:\nraise errors.LoginRequirementError\nasync for book in self.browse_books(recommended_for=self._profile.name):\nyield book\nasync def get_recently_read_books(self) -&gt; AsyncIterator[mdl.PageBook]:\n\"\"\"Get recently read/opened books of the currently logged-in user.\"\"\"\nif self._profile is None:\nraise errors.LoginRequirementError\nasync for book in self.browse_books(tags=[f\"read:@{self._profile.id}@\"]):\nyield book\nasync def get_related_books(self, post_id: int) -&gt; AsyncIterator[mdl.PageBook]:\n\"\"\"Get books related to specific post by its ID.\"\"\"\nasync for page in BookPaginator(\nself._http_client, const.RELATED_BOOK_URL.format(post_id=post_id)\n):\nfor book in page.items:\nyield book\nasync def get_book(self, book_id: int) -&gt; mdl.Book:\n\"\"\"Get specific book by its ID.\"\"\"\nresponse = await self._http_client.get(f\"{const.BOOK_URL}/{book_id}\")\nif not response.ok:\nraise errors.PageNotFoundError(response.status, book_id=book_id)\nreturn mdl.Book(**response.json)\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.BookClient.browse_books","title":"<code>browse_books(order=None, rating=None, recommended_for=None, favorited_by=None, tags=None, added_by=None, voted=None, *, page_number=None, limit=None)</code>  <code>async</code>","text":"<p>Get books from book (pool) pages.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>Optional[types.BookOrder]</code> <p>Book order rule</p> <code>None</code> <code>rating</code> <code>Optional[types.Rating]</code> <p>Books rating</p> <code>None</code> <code>recommended_for</code> <code>Optional[str]</code> <p>Books recommended for specified user</p> <code>None</code> <code>favorited_by</code> <code>Optional[str]</code> <p>Books favorited by specified user</p> <code>None</code> <code>tags</code> <code>Optional[List[str]]</code> <p>Tags available for search</p> <code>None</code> <code>added_by</code> <code>Optional[List[str]]</code> <p>Books uploaded by specified users</p> <code>None</code> <code>voted</code> <code>Optional[str]</code> <p>Books voted by specified user</p> <code>None</code> <code>page_number</code> <code>Optional[int]</code> <p>Page number from which to start iteration</p> <code>None</code> <code>limit</code> <code>Optional[Annotated[int, ValueRange(1, 100)]]</code> <p>Maximum amount of books per page</p> <code>None</code> Source code in <code>sankaku/clients/clients.py</code> <pre><code>async def browse_books(\nself,\norder: Optional[types.BookOrder] = None,\nrating: Optional[types.Rating] = None,\nrecommended_for: Optional[str] = None,\nfavorited_by: Optional[str] = None,\ntags: Optional[List[str]] = None,\nadded_by: Optional[List[str]] = None,\nvoted: Optional[str] = None,\n*,\npage_number: Optional[int] = None,\nlimit: Optional[Annotated[int, ValueRange(1, 100)]] = None\n) -&gt; AsyncIterator[mdl.PageBook]:\n\"\"\"Get books from book (pool) pages.\n    Args:\n        order: Book order rule\n        rating: Books rating\n        recommended_for: Books recommended for specified user\n        favorited_by: Books favorited by specified user\n        tags: Tags available for search\n        added_by: Books uploaded by specified users\n        voted: Books voted by specified user\n        page_number: Page number from which to start iteration\n        limit: Maximum amount of books per page\n    \"\"\"\nasync for page in BookPaginator(\nself._http_client, const.BOOK_URL, **from_locals(locals())\n):\nfor book in page.items:\nyield book\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.BookClient.get_favorited_books","title":"<code>get_favorited_books()</code>  <code>async</code>","text":"<p>Shorthand way to get favorited books for the currently logged-in user.</p> Source code in <code>sankaku/clients/clients.py</code> <pre><code>async def get_favorited_books(self) -&gt; AsyncIterator[mdl.PageBook]:\n\"\"\"Shorthand way to get favorited books for the currently logged-in user.\"\"\"\nif self._profile is None:\nraise errors.LoginRequirementError\nasync for book in self.browse_books(favorited_by=self._profile.name):\nyield book\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.BookClient.get_recommended_books","title":"<code>get_recommended_books()</code>  <code>async</code>","text":"<p>Shorthand way to get recommended books for the currently logged-in user.</p> Source code in <code>sankaku/clients/clients.py</code> <pre><code>async def get_recommended_books(self) -&gt; AsyncIterator[mdl.PageBook]:\n\"\"\"Shorthand way to get recommended books for the currently logged-in user.\"\"\"\nif self._profile is None:\nraise errors.LoginRequirementError\nasync for book in self.browse_books(recommended_for=self._profile.name):\nyield book\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.BookClient.get_recently_read_books","title":"<code>get_recently_read_books()</code>  <code>async</code>","text":"<p>Get recently read/opened books of the currently logged-in user.</p> Source code in <code>sankaku/clients/clients.py</code> <pre><code>async def get_recently_read_books(self) -&gt; AsyncIterator[mdl.PageBook]:\n\"\"\"Get recently read/opened books of the currently logged-in user.\"\"\"\nif self._profile is None:\nraise errors.LoginRequirementError\nasync for book in self.browse_books(tags=[f\"read:@{self._profile.id}@\"]):\nyield book\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.BookClient.get_related_books","title":"<code>get_related_books(post_id)</code>  <code>async</code>","text":"<p>Get books related to specific post by its ID.</p> Source code in <code>sankaku/clients/clients.py</code> <pre><code>async def get_related_books(self, post_id: int) -&gt; AsyncIterator[mdl.PageBook]:\n\"\"\"Get books related to specific post by its ID.\"\"\"\nasync for page in BookPaginator(\nself._http_client, const.RELATED_BOOK_URL.format(post_id=post_id)\n):\nfor book in page.items:\nyield book\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.BookClient.get_book","title":"<code>get_book(book_id)</code>  <code>async</code>","text":"<p>Get specific book by its ID.</p> Source code in <code>sankaku/clients/clients.py</code> <pre><code>async def get_book(self, book_id: int) -&gt; mdl.Book:\n\"\"\"Get specific book by its ID.\"\"\"\nresponse = await self._http_client.get(f\"{const.BOOK_URL}/{book_id}\")\nif not response.ok:\nraise errors.PageNotFoundError(response.status, book_id=book_id)\nreturn mdl.Book(**response.json)\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.UserClient","title":"<code>sankaku.clients.clients.UserClient</code>","text":"<p>         Bases: <code>BaseClient</code></p> <p>Client for browsing users.</p> Source code in <code>sankaku/clients/clients.py</code> <pre><code>class UserClient(BaseClient):\n\"\"\"Client for browsing users.\"\"\"\nasync def browse_users(\nself,\norder: Optional[types.UserOrder] = None,\nlevel: Optional[types.UserLevel] = None,\n*,\npage_number: Optional[int] = None,\nlimit: Optional[Annotated[int, ValueRange(1, 100)]] = None\n) -&gt; AsyncIterator[mdl.User]:\n\"\"\"Get user profiles from user pages.\n        Args:\n            order: User order rule\n            level: User level type\n            page_number: Page number from which to start iteration\n            limit: Maximum amount of users per page\n        \"\"\"\nasync for page in UserPaginator(\nself._http_client, const.USER_URL, **from_locals(locals())\n):\nfor user in page.items:\nyield user\nasync def get_user(self, name_or_id: Union[str, int]) -&gt; mdl.User:\n\"\"\"Get specific user by its name or ID.\"\"\"\nref = \"/name\" if isinstance(name_or_id, str) else \"\"\nurl = f\"{const.USER_URL}{ref}/{name_or_id}\"\nresponse = await self._http_client.get(url)\nif not response.ok:\nraise errors.PageNotFoundError(response.status, name_or_id=name_or_id)\nreturn mdl.User(**response.json)\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.UserClient.browse_users","title":"<code>browse_users(order=None, level=None, *, page_number=None, limit=None)</code>  <code>async</code>","text":"<p>Get user profiles from user pages.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>Optional[types.UserOrder]</code> <p>User order rule</p> <code>None</code> <code>level</code> <code>Optional[types.UserLevel]</code> <p>User level type</p> <code>None</code> <code>page_number</code> <code>Optional[int]</code> <p>Page number from which to start iteration</p> <code>None</code> <code>limit</code> <code>Optional[Annotated[int, ValueRange(1, 100)]]</code> <p>Maximum amount of users per page</p> <code>None</code> Source code in <code>sankaku/clients/clients.py</code> <pre><code>async def browse_users(\nself,\norder: Optional[types.UserOrder] = None,\nlevel: Optional[types.UserLevel] = None,\n*,\npage_number: Optional[int] = None,\nlimit: Optional[Annotated[int, ValueRange(1, 100)]] = None\n) -&gt; AsyncIterator[mdl.User]:\n\"\"\"Get user profiles from user pages.\n    Args:\n        order: User order rule\n        level: User level type\n        page_number: Page number from which to start iteration\n        limit: Maximum amount of users per page\n    \"\"\"\nasync for page in UserPaginator(\nself._http_client, const.USER_URL, **from_locals(locals())\n):\nfor user in page.items:\nyield user\n</code></pre>"},{"location":"api/clients/clients/#sankaku.clients.clients.UserClient.get_user","title":"<code>get_user(name_or_id)</code>  <code>async</code>","text":"<p>Get specific user by its name or ID.</p> Source code in <code>sankaku/clients/clients.py</code> <pre><code>async def get_user(self, name_or_id: Union[str, int]) -&gt; mdl.User:\n\"\"\"Get specific user by its name or ID.\"\"\"\nref = \"/name\" if isinstance(name_or_id, str) else \"\"\nurl = f\"{const.USER_URL}{ref}/{name_or_id}\"\nresponse = await self._http_client.get(url)\nif not response.ok:\nraise errors.PageNotFoundError(response.status, name_or_id=name_or_id)\nreturn mdl.User(**response.json)\n</code></pre>"},{"location":"api/clients/http_client/","title":"Documentation for <code>http_client.py</code>","text":""},{"location":"api/clients/http_client/#sankaku.clients.http_client.HttpClient","title":"<code>sankaku.clients.http_client.HttpClient</code>","text":"<p>         Bases: <code>ABCHttpClient</code></p> <p>HTTP client for API requests that instances use a single session.</p> Source code in <code>sankaku/clients/http_client.py</code> <pre><code>class HttpClient(ABCHttpClient):\n\"\"\"HTTP client for API requests that instances use a single session.\"\"\"\ndef __init__(self) -&gt; None:\nself.headers: Dict[str, str] = const.HEADERS.copy()\nsocks_connector = _get_socks_connector()\nif socks_connector is not None:\n# use socks connector\nkwargs = {\"connector\": socks_connector}\nelse:\n# use trust env option, aiohttp will read HTTP_PROXY and HTTPS_PROXY from env\nkwargs = {\"trust_env\": True}\nself._client_session: ClientSession = ClientSession(**kwargs)\nretry_options = ExponentialRetry(attempts=BASE_RETRIES)\nself.session: RetryClient = RetryClient(\nraise_for_status=False,\nretry_options=retry_options,\nclient_session=self._client_session\n)\ndef __del__(self) -&gt; None:\nif not self._client_session.closed and self._client_session.connector is not None:\nself._client_session.connector.close()\nasync def close(self) -&gt; None:\n\"\"\"There is no need to close client with single session.\"\"\"\nasync def request(self, method: str, url: str, **kwargs) -&gt; ClientResponse:\n\"\"\"Make request to specified url.\"\"\"\nif kwargs.get(\"headers\") is None:\nkwargs[\"headers\"] = self.headers\nresponse = await self.session.request(method, url, **kwargs)\nlogger.debug(f\"Sent {method} request to {response.url}\")\nif response.content_type != \"application/json\":\nraise errors.SankakuServerError(\nresponse.status, \"Invalid response content type\",\ncontent_type=response.content_type\n)\nclient_response = ClientResponse(\nresponse.status,\nawait response.json(encoding=\"utf-8\"),\n)\nresponse.close()\nlogger.debug(\nf\"Request {method} returned response with status \"\nf\"[{client_response.status}]: {client_response.json}\",\n)\nreturn client_response\nasync def get(self, url: str, **kwargs) -&gt; ClientResponse:\n\"\"\"Send GET request to specified url.\"\"\"\nreturn await self.request(\"GET\", url, **kwargs)\nasync def post(self, url: str, **kwargs) -&gt; ClientResponse:\n\"\"\"Send POST request to specified url.\"\"\"\nreturn await self.request(\"POST\", url, **kwargs)\n</code></pre>"},{"location":"api/clients/http_client/#sankaku.clients.http_client.HttpClient.close","title":"<code>close()</code>  <code>async</code>","text":"<p>There is no need to close client with single session.</p> Source code in <code>sankaku/clients/http_client.py</code> <pre><code>async def close(self) -&gt; None:\n\"\"\"There is no need to close client with single session.\"\"\"\n</code></pre>"},{"location":"api/clients/http_client/#sankaku.clients.http_client.HttpClient.request","title":"<code>request(method, url, **kwargs)</code>  <code>async</code>","text":"<p>Make request to specified url.</p> Source code in <code>sankaku/clients/http_client.py</code> <pre><code>async def request(self, method: str, url: str, **kwargs) -&gt; ClientResponse:\n\"\"\"Make request to specified url.\"\"\"\nif kwargs.get(\"headers\") is None:\nkwargs[\"headers\"] = self.headers\nresponse = await self.session.request(method, url, **kwargs)\nlogger.debug(f\"Sent {method} request to {response.url}\")\nif response.content_type != \"application/json\":\nraise errors.SankakuServerError(\nresponse.status, \"Invalid response content type\",\ncontent_type=response.content_type\n)\nclient_response = ClientResponse(\nresponse.status,\nawait response.json(encoding=\"utf-8\"),\n)\nresponse.close()\nlogger.debug(\nf\"Request {method} returned response with status \"\nf\"[{client_response.status}]: {client_response.json}\",\n)\nreturn client_response\n</code></pre>"},{"location":"api/clients/http_client/#sankaku.clients.http_client.HttpClient.get","title":"<code>get(url, **kwargs)</code>  <code>async</code>","text":"<p>Send GET request to specified url.</p> Source code in <code>sankaku/clients/http_client.py</code> <pre><code>async def get(self, url: str, **kwargs) -&gt; ClientResponse:\n\"\"\"Send GET request to specified url.\"\"\"\nreturn await self.request(\"GET\", url, **kwargs)\n</code></pre>"},{"location":"api/clients/http_client/#sankaku.clients.http_client.HttpClient.post","title":"<code>post(url, **kwargs)</code>  <code>async</code>","text":"<p>Send POST request to specified url.</p> Source code in <code>sankaku/clients/http_client.py</code> <pre><code>async def post(self, url: str, **kwargs) -&gt; ClientResponse:\n\"\"\"Send POST request to specified url.\"\"\"\nreturn await self.request(\"POST\", url, **kwargs)\n</code></pre>"},{"location":"api/models/base/","title":"Documentation for <code>base.py</code>","text":""},{"location":"api/models/base/#sankaku.models.base.SankakuResponseModel","title":"<code>sankaku.models.base.SankakuResponseModel</code>","text":"<p>         Bases: <code>BaseModel</code></p> <p>Base model for sankaku JSON responses.</p> Source code in <code>sankaku/models/base.py</code> <pre><code>class SankakuResponseModel(BaseModel, extra=Extra.forbid):\n\"\"\"Base model for sankaku JSON responses.\"\"\"\n</code></pre>"},{"location":"api/models/books/","title":"Documentation for <code>books.py</code>","text":""},{"location":"api/models/books/#sankaku.models.books.BookState","title":"<code>sankaku.models.books.BookState</code>","text":"<p>         Bases: <code>SankakuResponseModel</code></p>"},{"location":"api/models/books/#sankaku.models.books.BookState.current_page","title":"<code>current_page: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.BookState.sequence","title":"<code>sequence: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.BookState.post_id","title":"<code>post_id: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.BookState.series_id","title":"<code>series_id: Optional[int]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.BookState.created_at","title":"<code>created_at: datetime</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.BookState.updated_at","title":"<code>updated_at: datetime</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.BookState.percent","title":"<code>percent: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook","title":"<code>sankaku.models.books.PageBook</code>","text":"<p>         Bases: <code>SankakuResponseModel</code></p> <p>Model that describes books on book pages.</p>"},{"location":"api/models/books/#sankaku.models.books.PageBook.id","title":"<code>id: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.name_en","title":"<code>name_en: Optional[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.name_ja","title":"<code>name_ja: Optional[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.description","title":"<code>description: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.description_en","title":"<code>description_en: Optional[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.description_ja","title":"<code>description_ja: Optional[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.created_at","title":"<code>created_at: datetime</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.updated_at","title":"<code>updated_at: datetime</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.author","title":"<code>author: Author</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.is_public","title":"<code>is_public: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.is_active","title":"<code>is_active: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.is_flagged","title":"<code>is_flagged: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.post_count","title":"<code>post_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.pages_count","title":"<code>pages_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.visible_post_count","title":"<code>visible_post_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.is_intact","title":"<code>is_intact: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.rating","title":"<code>rating: Optional[types.Rating]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.parent_id","title":"<code>parent_id: Optional[int]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.has_children","title":"<code>has_children: Optional[bool]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.is_rating_locked","title":"<code>is_rating_locked: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.fav_count","title":"<code>fav_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.vote_count","title":"<code>vote_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.total_score","title":"<code>total_score: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.comment_count","title":"<code>comment_count: Optional[int]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.tags","title":"<code>tags: List[PostTag]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.post_tags","title":"<code>post_tags: List[PostTag]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.artist_tags","title":"<code>artist_tags: List[PostTag]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.genre_tags","title":"<code>genre_tags: List[PostTag]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.is_favorited","title":"<code>is_favorited: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.user_vote","title":"<code>user_vote: Optional[int]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.posts","title":"<code>posts: List[Post]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.file_url","title":"<code>file_url: Optional[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.sample_url","title":"<code>sample_url: Optional[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.preview_url","title":"<code>preview_url: Optional[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.cover_post","title":"<code>cover_post: Optional[Post]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.reading","title":"<code>reading: Optional[BookState]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.is_premium","title":"<code>is_premium: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.is_pending","title":"<code>is_pending: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.is_raw","title":"<code>is_raw: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.is_trial","title":"<code>is_trial: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.redirect_to_signup","title":"<code>redirect_to_signup: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.locale","title":"<code>locale: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.is_deleted","title":"<code>is_deleted: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.cover_post_id","title":"<code>cover_post_id: Optional[int]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.name","title":"<code>name: Optional[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.PageBook.parent_pool","title":"<code>parent_pool: Optional[PageBook]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.Book","title":"<code>sankaku.models.books.Book</code>","text":"<p>         Bases: <code>PageBook</code></p> <p>Model that describes specific book.</p>"},{"location":"api/models/books/#sankaku.models.books.Book.child_pools","title":"<code>child_pools: Optional[List[PageBook]]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.Book.flagged_by_user","title":"<code>flagged_by_user: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/books/#sankaku.models.books.Book.prem_post_count","title":"<code>prem_post_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/http/","title":"Documentation for <code>http.py</code>","text":""},{"location":"api/models/http/#sankaku.models.http.ClientResponse","title":"<code>sankaku.models.http.ClientResponse</code>  <code>dataclass</code>","text":"<p>Dataclass that preserves information from aiohttp ClientResponse.</p>"},{"location":"api/models/http/#sankaku.models.http.ClientResponse.status","title":"<code>status: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/http/#sankaku.models.http.ClientResponse.json","title":"<code>json: Any</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/http/#sankaku.models.http.ClientResponse.ok","title":"<code>ok: bool</code>  <code>property</code>","text":"<p>Check if response status code is less than 400.</p>"},{"location":"api/models/pages/","title":"Documentation for <code>pages.py</code>","text":""},{"location":"api/models/pages/#sankaku.models.pages.Page","title":"<code>sankaku.models.pages.Page</code>  <code>dataclass</code>","text":"<p>         Bases: <code>Generic[_T]</code></p> <p>Model that describes page containing content with specific type.</p>"},{"location":"api/models/pages/#sankaku.models.pages.Page.number","title":"<code>number: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/pages/#sankaku.models.pages.Page.items","title":"<code>items: List[_T]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/","title":"Documentation for <code>posts.py</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.GenerationDirectives","title":"<code>sankaku.models.posts.GenerationDirectives</code>","text":"<p>         Bases: <code>SankakuResponseModel</code></p> <p>Model that describes additional fields for AI-generated posts.</p>"},{"location":"api/models/posts/#sankaku.models.posts.GenerationDirectives.width","title":"<code>width: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.GenerationDirectives.height","title":"<code>height: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.GenerationDirectives.prompt","title":"<code>prompt: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.GenerationDirectives.batch_size","title":"<code>batch_size: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.GenerationDirectives.batch_count","title":"<code>batch_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.GenerationDirectives.sampling_steps","title":"<code>sampling_steps: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.GenerationDirectives.negative_prompt","title":"<code>negative_prompt: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.GenerationDirectives.version","title":"<code>version: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.BasePost","title":"<code>sankaku.models.posts.BasePost</code>","text":"<p>         Bases: <code>SankakuResponseModel</code></p> <p>Model that contains minimum amount of information that all posts have.</p>"},{"location":"api/models/posts/#sankaku.models.posts.BasePost.id","title":"<code>id: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.BasePost.created_at","title":"<code>created_at: datetime</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.BasePost.rating","title":"<code>rating: types.Rating</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.BasePost.status","title":"<code>status: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.BasePost.author","title":"<code>author: Author</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.BasePost.file_url","title":"<code>file_url: Optional[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.BasePost.preview_url","title":"<code>preview_url: Optional[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.BasePost.width","title":"<code>width: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.BasePost.height","title":"<code>height: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.BasePost.file_size","title":"<code>file_size: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.BasePost.extension","title":"<code>extension: Optional[str] = Field(alias='file_type')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.BasePost.generation_directives","title":"<code>generation_directives: Optional[GenerationDirectives]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.BasePost.md5","title":"<code>md5: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.BasePost.tags","title":"<code>tags: List[PostTag]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.BasePost.file_type","title":"<code>file_type: Optional[types.FileType]</code>  <code>property</code>","text":"<p>Get type of the file.</p>"},{"location":"api/models/posts/#sankaku.models.posts.Comment","title":"<code>sankaku.models.posts.Comment</code>","text":"<p>         Bases: <code>SankakuResponseModel</code></p> <p>Model that describes comments related to posts if they are exist.</p>"},{"location":"api/models/posts/#sankaku.models.posts.Comment.id","title":"<code>id: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Comment.created_at","title":"<code>created_at: datetime</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Comment.post_id","title":"<code>post_id: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Comment.author","title":"<code>author: Author</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Comment.body","title":"<code>body: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Comment.score","title":"<code>score: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Comment.parent_id","title":"<code>parent_id: Optional[int]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Comment.children","title":"<code>children: List[Comment]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Comment.deleted","title":"<code>deleted: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Comment.deleted_by","title":"<code>deleted_by: dict</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Comment.updated_at","title":"<code>updated_at: Optional[datetime]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Comment.can_reply","title":"<code>can_reply: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Comment.reason","title":"<code>reason: None</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post","title":"<code>sankaku.models.posts.Post</code>","text":"<p>         Bases: <code>BasePost</code></p> <p>Model that describes posts.</p>"},{"location":"api/models/posts/#sankaku.models.posts.Post.sample_url","title":"<code>sample_url: Optional[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.sample_width","title":"<code>sample_width: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.sample_height","title":"<code>sample_height: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.preview_width","title":"<code>preview_width: Optional[int]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.preview_height","title":"<code>preview_height: Optional[int]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.has_children","title":"<code>has_children: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.has_comments","title":"<code>has_comments: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.has_notes","title":"<code>has_notes: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.is_favorited","title":"<code>is_favorited: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.user_vote","title":"<code>user_vote: Optional[int]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.parent_id","title":"<code>parent_id: Optional[int]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.change","title":"<code>change: Optional[int]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.fav_count","title":"<code>fav_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.recommended_posts","title":"<code>recommended_posts: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.recommended_score","title":"<code>recommended_score: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.vote_count","title":"<code>vote_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.total_score","title":"<code>total_score: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.comment_count","title":"<code>comment_count: Optional[int]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.source","title":"<code>source: Optional[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.in_visible_pool","title":"<code>in_visible_pool: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.is_premium","title":"<code>is_premium: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.is_rating_locked","title":"<code>is_rating_locked: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.is_note_locked","title":"<code>is_note_locked: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.is_status_locked","title":"<code>is_status_locked: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.redirect_to_signup","title":"<code>redirect_to_signup: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.sequence","title":"<code>sequence: Optional[int]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.Post.video_duration","title":"<code>video_duration: Optional[float]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.AIPost","title":"<code>sankaku.models.posts.AIPost</code>","text":"<p>         Bases: <code>BasePost</code></p> <p>Model that describes AI-generated posts.</p> <p>There is possibility that AI posts have the same fields as common posts, but premium account is needed to check it properly. So this model is actual for non-premium accounts.</p>"},{"location":"api/models/posts/#sankaku.models.posts.AIPost.updated_at","title":"<code>updated_at: Optional[datetime]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/posts/#sankaku.models.posts.AIPost.post_associated_id","title":"<code>post_associated_id: Optional[int]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/","title":"Documentation for <code>tags.py</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.BaseTag","title":"<code>sankaku.models.tags.BaseTag</code>","text":"<p>         Bases: <code>SankakuResponseModel</code></p> <p>Model that contains minimum amount of information that all tags have.</p>"},{"location":"api/models/tags/#sankaku.models.tags.BaseTag.id","title":"<code>id: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.BaseTag.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.BaseTag.name_en","title":"<code>name_en: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.BaseTag.name_ja","title":"<code>name_ja: Optional[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.BaseTag.type","title":"<code>type: types.TagType</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.BaseTag.post_count","title":"<code>post_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.BaseTag.pool_count","title":"<code>pool_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.BaseTag.series_count","title":"<code>series_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.BaseTag.rating","title":"<code>rating: Optional[types.Rating]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.TagMixin","title":"<code>sankaku.models.tags.TagMixin</code>","text":"<p>         Bases: <code>SankakuResponseModel</code></p> <p>Additional data that certain tags have.</p>"},{"location":"api/models/tags/#sankaku.models.tags.TagMixin.count","title":"<code>count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.TagMixin.tag_name","title":"<code>tag_name: str = Field(alias='tagName')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.TagMixin.total_post_count","title":"<code>total_post_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.TagMixin.total_pool_count","title":"<code>total_pool_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.PostTag","title":"<code>sankaku.models.tags.PostTag</code>","text":"<p>         Bases: <code>BaseTag</code>, <code>TagMixin</code></p> <p>Model that describes tags related to posts.</p>"},{"location":"api/models/tags/#sankaku.models.tags.PostTag.locale","title":"<code>locale: Optional[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.PostTag.version","title":"<code>version: Optional[int]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag","title":"<code>sankaku.models.tags.NestedTag</code>","text":"<p>         Bases: <code>BaseTag</code></p> <p>Model that describes tags with specific relation to certain tag on tag page.</p>"},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.post_count","title":"<code>post_count: int = Field(alias='postCount')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.cached_related","title":"<code>cached_related: Optional[List[int]] = Field(alias='cachedRelated')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.cached_related_expires_on","title":"<code>cached_related_expires_on: datetime = Field(alias='cachedRelatedExpiresOn')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.type","title":"<code>type: types.TagType = Field(alias='tagType')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.name_en","title":"<code>name_en: str = Field(alias='nameEn')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.name_ja","title":"<code>name_ja: Optional[str] = Field(alias='nameJa')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.popularity_all","title":"<code>popularity_all: Optional[float] = Field(alias='scTagPopularityAll')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.quality_all","title":"<code>quality_all: Optional[float] = Field(alias='scTagQualityAll')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.popularity_ero","title":"<code>popularity_ero: Optional[float] = Field(alias='scTagPopularityEro')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.popularity_safe","title":"<code>popularity_safe: Optional[float] = Field(alias='scTagPopularitySafe')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.quality_ero","title":"<code>quality_ero: Optional[float] = Field(alias='scTagQualityEro')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.quality_safe","title":"<code>quality_safe: Optional[float] = Field(alias='scTagQualitySafe')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.parent_tags","title":"<code>parent_tags: Optional[List[int]] = Field(alias='parentTags')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.child_tags","title":"<code>child_tags: Optional[List[int]] = Field(alias='childTags')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.pool_count","title":"<code>pool_count: int = Field(alias='poolCount')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.premium_post_count","title":"<code>premium_post_count: int = Field(alias='premPostCount')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.non_premium_post_count","title":"<code>non_premium_post_count: int = Field(alias='nonPremPostCount')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.premium_pool_count","title":"<code>premium_pool_count: int = Field(alias='premPoolCount')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.non_premium_pool_count","title":"<code>non_premium_pool_count: int = Field(alias='nonPremPoolCount')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.series_count","title":"<code>series_count: int = Field(alias='seriesCount')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.premium_series_count","title":"<code>premium_series_count: int = Field(alias='premSeriesCount')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.non_premium_series_count","title":"<code>non_premium_series_count: int = Field(alias='nonPremSeriesCount')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.is_trained","title":"<code>is_trained: bool = Field(alias='isTrained')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.child","title":"<code>child: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.parent","title":"<code>parent: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.NestedTag.version","title":"<code>version: Optional[int]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.BaseTranslations","title":"<code>sankaku.models.tags.BaseTranslations</code>","text":"<p>         Bases: <code>SankakuResponseModel</code></p> <p>Model that contain minimum information about tag translations.</p>"},{"location":"api/models/tags/#sankaku.models.tags.BaseTranslations.lang","title":"<code>lang: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.BaseTranslations.translation","title":"<code>translation: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.PageTagTranslations","title":"<code>sankaku.models.tags.PageTagTranslations</code>","text":"<p>         Bases: <code>BaseTranslations</code></p> <p>Model that describes page tag translations.</p>"},{"location":"api/models/tags/#sankaku.models.tags.PageTagTranslations.root_id","title":"<code>root_id: int = Field(alias='rootId')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.WikiTagTranslations","title":"<code>sankaku.models.tags.WikiTagTranslations</code>","text":"<p>         Bases: <code>BaseTranslations</code></p> <p>Model that describes wiki tag translations.</p>"},{"location":"api/models/tags/#sankaku.models.tags.WikiTagTranslations.status","title":"<code>status: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.WikiTagTranslations.opacity","title":"<code>opacity: float</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.WikiTagTranslations.id","title":"<code>id: Optional[int] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.PageTag","title":"<code>sankaku.models.tags.PageTag</code>","text":"<p>         Bases: <code>PostTag</code></p> <p>Model that describes tags on tag page.</p>"},{"location":"api/models/tags/#sankaku.models.tags.PageTag.translations","title":"<code>translations: List[PageTagTranslations]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.PageTag.related_tags","title":"<code>related_tags: List[NestedTag]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.PageTag.child_tags","title":"<code>child_tags: List[NestedTag]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.PageTag.parent_tags","title":"<code>parent_tags: List[NestedTag]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.Wiki","title":"<code>sankaku.models.tags.Wiki</code>","text":"<p>         Bases: <code>SankakuResponseModel</code></p> <p>Model that describes wiki information for specific tag.</p>"},{"location":"api/models/tags/#sankaku.models.tags.Wiki.id","title":"<code>id: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.Wiki.title","title":"<code>title: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.Wiki.body","title":"<code>body: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.Wiki.created_at","title":"<code>created_at: datetime</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.Wiki.updated_at","title":"<code>updated_at: Optional[datetime]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.Wiki.author","title":"<code>author: Author = Field(alias='user')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.Wiki.is_locked","title":"<code>is_locked: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.Wiki.version","title":"<code>version: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.WikiTag","title":"<code>sankaku.models.tags.WikiTag</code>","text":"<p>         Bases: <code>BaseTag</code>, <code>TagMixin</code></p> <p>Model that describes tag on wiki page.</p>"},{"location":"api/models/tags/#sankaku.models.tags.WikiTag.related_tags","title":"<code>related_tags: List[PostTag]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.WikiTag.child_tags","title":"<code>child_tags: List[PostTag]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.WikiTag.parent_tags","title":"<code>parent_tags: List[PostTag]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.WikiTag.alias_tags","title":"<code>alias_tags: List[PostTag]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.WikiTag.implied_tags","title":"<code>implied_tags: List[PostTag]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.WikiTag.translations","title":"<code>translations: List[WikiTagTranslations]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/tags/#sankaku.models.tags.WikiTag.wiki","title":"<code>wiki: Wiki</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/","title":"Documentation for <code>users.py</code>","text":""},{"location":"api/models/users/#sankaku.models.users.BaseUser","title":"<code>sankaku.models.users.BaseUser</code>","text":"<p>         Bases: <code>SankakuResponseModel</code></p> <p>User profile with a minimum amount of information.</p>"},{"location":"api/models/users/#sankaku.models.users.BaseUser.id","title":"<code>id: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.BaseUser.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.BaseUser.avatar","title":"<code>avatar: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.BaseUser.avatar_rating","title":"<code>avatar_rating: types.Rating</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.Author","title":"<code>sankaku.models.users.Author</code>","text":"<p>         Bases: <code>BaseUser</code></p> <p>Model that describes users who are the authors of posts or wiki pages.</p>"},{"location":"api/models/users/#sankaku.models.users.User","title":"<code>sankaku.models.users.User</code>","text":"<p>         Bases: <code>BaseUser</code></p> <p>User profile model for any user that has an account on website.</p>"},{"location":"api/models/users/#sankaku.models.users.User.level","title":"<code>level: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.upload_limit","title":"<code>upload_limit: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.created_at","title":"<code>created_at: datetime</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.favs_are_private","title":"<code>favs_are_private: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.avatar","title":"<code>avatar: str = Field(alias='avatar_url')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.post_upload_count","title":"<code>post_upload_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.pool_upload_count","title":"<code>pool_upload_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.comment_count","title":"<code>comment_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.post_update_count","title":"<code>post_update_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.note_update_count","title":"<code>note_update_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.wiki_update_count","title":"<code>wiki_update_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.forum_post_count","title":"<code>forum_post_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.pool_update_count","title":"<code>pool_update_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.series_update_count","title":"<code>series_update_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.tag_update_count","title":"<code>tag_update_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.artist_update_count","title":"<code>artist_update_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.last_logged_in_at","title":"<code>last_logged_in_at: Optional[datetime] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.favorite_count","title":"<code>favorite_count: Optional[int] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.post_favorite_count","title":"<code>post_favorite_count: Optional[int]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.pool_favorite_count","title":"<code>pool_favorite_count: Optional[int]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.vote_count","title":"<code>vote_count: Optional[int] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.post_vote_count","title":"<code>post_vote_count: Optional[int] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.pool_vote_count","title":"<code>pool_vote_count: Optional[int] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.recommended_posts_for_user","title":"<code>recommended_posts_for_user: Optional[int] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.subscriptions","title":"<code>subscriptions: List[str] = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.show_popup_version","title":"<code>show_popup_version: Optional[int] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.credits","title":"<code>credits: Optional[int] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.credits_subs","title":"<code>credits_subs: Optional[int] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.User.is_ai_beta","title":"<code>is_ai_beta: Optional[bool] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.ExtendedUser","title":"<code>sankaku.models.users.ExtendedUser</code>","text":"<p>         Bases: <code>User</code></p> <p>Profile of the currently logged-in user.</p>"},{"location":"api/models/users/#sankaku.models.users.ExtendedUser.email","title":"<code>email: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.ExtendedUser.hide_ads","title":"<code>hide_ads: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.ExtendedUser.subscription_level","title":"<code>subscription_level: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.ExtendedUser.filter_content","title":"<code>filter_content: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.ExtendedUser.receive_dmails","title":"<code>receive_dmails: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.ExtendedUser.email_verification_status","title":"<code>email_verification_status: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.ExtendedUser.is_verified","title":"<code>is_verified: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.ExtendedUser.verifications_count","title":"<code>verifications_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.ExtendedUser.blacklist_is_hidden","title":"<code>blacklist_is_hidden: bool</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.ExtendedUser.blacklisted_tags","title":"<code>blacklisted_tags: List[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.ExtendedUser.blacklisted","title":"<code>blacklisted: List[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/users/#sankaku.models.users.ExtendedUser.mfa_method","title":"<code>mfa_method: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/paginators/abc/","title":"Documentation for <code>abc.py</code>","text":""},{"location":"api/paginators/abc/#sankaku.paginators.abc.ABCPaginator","title":"<code>sankaku.paginators.abc.ABCPaginator</code>","text":"<p>         Bases: <code>ABC</code>, <code>Generic[_T]</code></p> <p>Abstract paginator class.</p> Source code in <code>sankaku/paginators/abc.py</code> <pre><code>class ABCPaginator(ABC, Generic[_T]):\n\"\"\"Abstract paginator class.\"\"\"\n@abstractmethod\ndef __init__(self, *args, **kwargs) -&gt; None:\npass\ndef __aiter__(self) -&gt; AsyncIterator[mdl.Page[_T]]:\nreturn self\nasync def __anext__(self) -&gt; mdl.Page[_T]:\ntry:\nreturn await self.next_page()\nexcept errors.PaginatorLastPage:\nraise StopAsyncIteration\n@abstractmethod\nasync def next_page(self) -&gt; mdl.Page[_T]:\n\"\"\"Get paginator next page.\"\"\"\n@abstractmethod\ndef complete_params(self) -&gt; None:\n\"\"\"Complete params passed to paginator for further use.\"\"\"\n</code></pre>"},{"location":"api/paginators/abc/#sankaku.paginators.abc.ABCPaginator.next_page","title":"<code>next_page()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get paginator next page.</p> Source code in <code>sankaku/paginators/abc.py</code> <pre><code>@abstractmethod\nasync def next_page(self) -&gt; mdl.Page[_T]:\n\"\"\"Get paginator next page.\"\"\"\n</code></pre>"},{"location":"api/paginators/paginators/","title":"Documentation for <code>paginators.py</code>","text":""},{"location":"api/paginators/paginators/#sankaku.paginators.paginators.Paginator","title":"<code>sankaku.paginators.paginators.Paginator</code>","text":"<p>         Bases: <code>ABCPaginator[_T]</code></p> <p>Basic paginator for iteration without any special parameters.</p> Source code in <code>sankaku/paginators/paginators.py</code> <pre><code>class Paginator(ABCPaginator[_T]):\n\"\"\"Basic paginator for iteration without any special parameters.\"\"\"\ndef __init__(\nself,\nhttp_client: HttpClient,\nurl: str,\nmodel: Type[_T],\npage_number: Optional[int] = None,\nlimit: Optional[Annotated[int, ValueRange(1, 100)]] = None,\nparams: Optional[Dict[str, str]] = None\n) -&gt; None:\nself.http_client = http_client\nself.url = url\nself.model = model\nself.page_number = page_number or const.BASE_PAGE_NUMBER\nself.limit = limit or const.BASE_PAGE_LIMIT\nself.params: Dict[str, str] = params or {}\nself.complete_params()\n@ratelimit(rps=const.BASE_RPS)\nasync def next_page(self) -&gt; mdl.Page[_T]:  # type: ignore[override]\n\"\"\"Get paginator next page.\"\"\"\nresponse = await self.http_client.get(self.url, params=self.params)\njson_ = response.json\nif \"code\" in json_ and json_[\"code\"] in const.PAGE_ALLOWED_ERRORS:\nraise errors.PaginatorLastPage(response.status, page=self.page_number)\nelif \"code\" in json_:\nraise errors.SankakuServerError(response.status, **response.json)\nelif json_ == [] or (isinstance(json_, dict) and not json_[\"data\"]):\nraise errors.PaginatorLastPage(response.status, page=self.page_number)\nelif \"data\" in json_:\nresponse.json = json_[\"data\"]\nself.page_number += 1\nself.params[\"page\"] = str(self.page_number)\nreturn self._construct_page(response.json)\ndef complete_params(self) -&gt; None:\n\"\"\"Complete params passed to paginator for further use.\"\"\"\nself.params[\"lang\"] = \"en\"\nif self.page_number is not None:\nself.params[\"page\"] = str(self.page_number)\nif self.limit is not None:\nself.params[\"limit\"] = str(self.limit)\ndef _construct_page(self, data: List[dict]) -&gt; mdl.Page[_T]:\n\"\"\"Construct and return page model.\"\"\"\nitems = [self.model(**d) for d in data]\nreturn mdl.Page[_T](number=self.page_number - 1, items=items)\n</code></pre>"},{"location":"api/paginators/paginators/#sankaku.paginators.paginators.Paginator.__init__","title":"<code>__init__(http_client, url, model, page_number=None, limit=None, params=None)</code>","text":"Source code in <code>sankaku/paginators/paginators.py</code> <pre><code>def __init__(\nself,\nhttp_client: HttpClient,\nurl: str,\nmodel: Type[_T],\npage_number: Optional[int] = None,\nlimit: Optional[Annotated[int, ValueRange(1, 100)]] = None,\nparams: Optional[Dict[str, str]] = None\n) -&gt; None:\nself.http_client = http_client\nself.url = url\nself.model = model\nself.page_number = page_number or const.BASE_PAGE_NUMBER\nself.limit = limit or const.BASE_PAGE_LIMIT\nself.params: Dict[str, str] = params or {}\nself.complete_params()\n</code></pre>"},{"location":"api/paginators/paginators/#sankaku.paginators.paginators.Paginator.next_page","title":"<code>next_page()</code>  <code>async</code>","text":"<p>Get paginator next page.</p> Source code in <code>sankaku/paginators/paginators.py</code> <pre><code>@ratelimit(rps=const.BASE_RPS)\nasync def next_page(self) -&gt; mdl.Page[_T]:  # type: ignore[override]\n\"\"\"Get paginator next page.\"\"\"\nresponse = await self.http_client.get(self.url, params=self.params)\njson_ = response.json\nif \"code\" in json_ and json_[\"code\"] in const.PAGE_ALLOWED_ERRORS:\nraise errors.PaginatorLastPage(response.status, page=self.page_number)\nelif \"code\" in json_:\nraise errors.SankakuServerError(response.status, **response.json)\nelif json_ == [] or (isinstance(json_, dict) and not json_[\"data\"]):\nraise errors.PaginatorLastPage(response.status, page=self.page_number)\nelif \"data\" in json_:\nresponse.json = json_[\"data\"]\nself.page_number += 1\nself.params[\"page\"] = str(self.page_number)\nreturn self._construct_page(response.json)\n</code></pre>"},{"location":"api/paginators/paginators/#sankaku.paginators.paginators.Paginator.complete_params","title":"<code>complete_params()</code>","text":"<p>Complete params passed to paginator for further use.</p> Source code in <code>sankaku/paginators/paginators.py</code> <pre><code>def complete_params(self) -&gt; None:\n\"\"\"Complete params passed to paginator for further use.\"\"\"\nself.params[\"lang\"] = \"en\"\nif self.page_number is not None:\nself.params[\"page\"] = str(self.page_number)\nif self.limit is not None:\nself.params[\"limit\"] = str(self.limit)\n</code></pre>"},{"location":"api/paginators/paginators/#sankaku.paginators.paginators.PostPaginator","title":"<code>sankaku.paginators.paginators.PostPaginator</code>","text":"<p>         Bases: <code>Paginator[mdl.Post]</code></p> <p>Paginator used for iteration through post pages.</p> Source code in <code>sankaku/paginators/paginators.py</code> <pre><code>class PostPaginator(Paginator[mdl.Post]):\n\"\"\"Paginator used for iteration through post pages.\"\"\"\ndef __init__(\nself,\nhttp_client: HttpClient,\nurl: str,\nmodel: Type[mdl.Post] = mdl.Post,\npage_number: Optional[int] = None,\nlimit: Optional[Annotated[int, ValueRange(1, 100)]] = None,\nparams: Optional[Dict[str, str]] = None,\norder: Optional[types.PostOrder] = None,\ndate: Optional[List[datetime]] = None,\nrating: Optional[types.Rating] = None,\nthreshold: Optional[Annotated[int, ValueRange(1, 100)]] = None,\nhide_posts_in_books: Optional[Literal[\"in-larger-tags\", \"always\"]] = None,\nfile_size: Optional[types.FileSize] = None,\nfile_type: Optional[types.FileType] = None,\nvideo_duration: Optional[List[int]] = None,\nrecommended_for: Optional[str] = None,\nfavorited_by: Optional[str] = None,\ntags: Optional[List[str]] = None,\nadded_by: Optional[List[str]] = None,\nvoted: Optional[str] = None\n) -&gt; None:\nself.order = order\nself.date = date\nself.rating = rating\nself.threshold = threshold\nself.hide_posts_in_books = hide_posts_in_books\nself.file_size = file_size\nself.file_type = file_type\nself.video_duration = video_duration\nself.recommended_for = recommended_for\nself.favorited_by = favorited_by\nself.tags = tags\nself.added_by = added_by\nself.voted = voted\nsuper().__init__(http_client, url, model, page_number, limit, params)\ndef complete_params(self) -&gt; None:\nsuper().complete_params()\nif self.tags is None:\nself.tags = []\nfor k, v in self.__dict__.items():\nif v is None:\ncontinue\nelif k in {\"order\", \"rating\", \"file_type\"} and v is not types.FileType.IMAGE:  # noqa\nself.tags.append(f\"{k}:{v.value}\")\nelif k in {\"threshold\", \"recommended_for\", \"voted\"}:\nself.tags.append(f\"{k}:{v}\")\nelif k == \"file_size\":\nself.tags.append(self.file_size.value)  # type: ignore[union-attr]\nelif k == \"date\":\ndate = \"..\".join(d.strftime(\"%Y-%m-%dT%H:%M\") for d in self.date)  # type: ignore[union-attr]\nself.tags.append(f\"date:{date}\")\nelif k == \"video_duration\" and self.file_type is not types.FileType.VIDEO:  # noqa\nraise errors.VideoDurationError\nelif k == \"video_duration\":\nduration = \"..\".join(str(sec) for sec in self.video_duration)  # type: ignore[union-attr]\nself.tags.append(f\"duration:{duration}\")\nelif k == \"favorited_by\":\nself.tags.append(f\"fav:{self.favorited_by}\")\nelif k == \"added_by\":\nfor user in self.added_by:  # type: ignore[union-attr]\nself.tags.append(f\"user:{user}\")\nif self.hide_posts_in_books is not None:\nself.params[\"hide_posts_in_books\"] = self.hide_posts_in_books\nif self.tags:\nself.params[\"tags\"] = \" \".join(self.tags)\n</code></pre>"},{"location":"api/paginators/paginators/#sankaku.paginators.paginators.PostPaginator.__init__","title":"<code>__init__(http_client, url, model=mdl.Post, page_number=None, limit=None, params=None, order=None, date=None, rating=None, threshold=None, hide_posts_in_books=None, file_size=None, file_type=None, video_duration=None, recommended_for=None, favorited_by=None, tags=None, added_by=None, voted=None)</code>","text":"Source code in <code>sankaku/paginators/paginators.py</code> <pre><code>def __init__(\nself,\nhttp_client: HttpClient,\nurl: str,\nmodel: Type[mdl.Post] = mdl.Post,\npage_number: Optional[int] = None,\nlimit: Optional[Annotated[int, ValueRange(1, 100)]] = None,\nparams: Optional[Dict[str, str]] = None,\norder: Optional[types.PostOrder] = None,\ndate: Optional[List[datetime]] = None,\nrating: Optional[types.Rating] = None,\nthreshold: Optional[Annotated[int, ValueRange(1, 100)]] = None,\nhide_posts_in_books: Optional[Literal[\"in-larger-tags\", \"always\"]] = None,\nfile_size: Optional[types.FileSize] = None,\nfile_type: Optional[types.FileType] = None,\nvideo_duration: Optional[List[int]] = None,\nrecommended_for: Optional[str] = None,\nfavorited_by: Optional[str] = None,\ntags: Optional[List[str]] = None,\nadded_by: Optional[List[str]] = None,\nvoted: Optional[str] = None\n) -&gt; None:\nself.order = order\nself.date = date\nself.rating = rating\nself.threshold = threshold\nself.hide_posts_in_books = hide_posts_in_books\nself.file_size = file_size\nself.file_type = file_type\nself.video_duration = video_duration\nself.recommended_for = recommended_for\nself.favorited_by = favorited_by\nself.tags = tags\nself.added_by = added_by\nself.voted = voted\nsuper().__init__(http_client, url, model, page_number, limit, params)\n</code></pre>"},{"location":"api/paginators/paginators/#sankaku.paginators.paginators.PostPaginator.complete_params","title":"<code>complete_params()</code>","text":"Source code in <code>sankaku/paginators/paginators.py</code> <pre><code>def complete_params(self) -&gt; None:\nsuper().complete_params()\nif self.tags is None:\nself.tags = []\nfor k, v in self.__dict__.items():\nif v is None:\ncontinue\nelif k in {\"order\", \"rating\", \"file_type\"} and v is not types.FileType.IMAGE:  # noqa\nself.tags.append(f\"{k}:{v.value}\")\nelif k in {\"threshold\", \"recommended_for\", \"voted\"}:\nself.tags.append(f\"{k}:{v}\")\nelif k == \"file_size\":\nself.tags.append(self.file_size.value)  # type: ignore[union-attr]\nelif k == \"date\":\ndate = \"..\".join(d.strftime(\"%Y-%m-%dT%H:%M\") for d in self.date)  # type: ignore[union-attr]\nself.tags.append(f\"date:{date}\")\nelif k == \"video_duration\" and self.file_type is not types.FileType.VIDEO:  # noqa\nraise errors.VideoDurationError\nelif k == \"video_duration\":\nduration = \"..\".join(str(sec) for sec in self.video_duration)  # type: ignore[union-attr]\nself.tags.append(f\"duration:{duration}\")\nelif k == \"favorited_by\":\nself.tags.append(f\"fav:{self.favorited_by}\")\nelif k == \"added_by\":\nfor user in self.added_by:  # type: ignore[union-attr]\nself.tags.append(f\"user:{user}\")\nif self.hide_posts_in_books is not None:\nself.params[\"hide_posts_in_books\"] = self.hide_posts_in_books\nif self.tags:\nself.params[\"tags\"] = \" \".join(self.tags)\n</code></pre>"},{"location":"api/paginators/paginators/#sankaku.paginators.paginators.TagPaginator","title":"<code>sankaku.paginators.paginators.TagPaginator</code>","text":"<p>         Bases: <code>Paginator[mdl.PageTag]</code></p> <p>Paginator used for iteration through tag pages.</p> Source code in <code>sankaku/paginators/paginators.py</code> <pre><code>class TagPaginator(Paginator[mdl.PageTag]):\n\"\"\"Paginator used for iteration through tag pages.\"\"\"\ndef __init__(\nself,\nhttp_client: HttpClient,\nurl: str,\nmodel: Type[mdl.PageTag] = mdl.PageTag,\npage_number: Optional[int] = None,\nlimit: Optional[Annotated[int, ValueRange(1, 100)]] = None,\nparams: Optional[Dict[str, str]] = None,\ntag_type: Optional[types.TagType] = None,\norder: Optional[types.TagOrder] = None,\nrating: Optional[types.Rating] = None,\nmax_post_count: Optional[int] = None,\nsort_parameter: Optional[types.SortParameter] = None,\nsort_direction: Optional[types.SortDirection] = None\n) -&gt; None:\nself.tag_type = tag_type\nself.order = order\nself.rating = rating\nself.max_post_count = max_post_count\nself.sort_parameter = sort_parameter\nself.sort_direction = sort_direction or types.SortDirection.DESC\nsuper().__init__(http_client, url, model, page_number, limit, params)\ndef complete_params(self) -&gt; None:\nsuper().complete_params()\nif self.tag_type is not None:\nself.params[\"types[]\"] = str(self.tag_type.value)\nif self.order is not None:\nself.params[\"order\"] = self.order.value\nif self.rating is not None:\nself.params[\"rating\"] = self.rating.value\nif self.max_post_count is not None:\nself.params[\"amount\"] = str(self.max_post_count)\nif self.sort_parameter is not None:\nself.params.update(\nsortBy=self.sort_parameter.value,\nsortDirection=self.sort_direction.value\n)\n</code></pre>"},{"location":"api/paginators/paginators/#sankaku.paginators.paginators.TagPaginator.__init__","title":"<code>__init__(http_client, url, model=mdl.PageTag, page_number=None, limit=None, params=None, tag_type=None, order=None, rating=None, max_post_count=None, sort_parameter=None, sort_direction=None)</code>","text":"Source code in <code>sankaku/paginators/paginators.py</code> <pre><code>def __init__(\nself,\nhttp_client: HttpClient,\nurl: str,\nmodel: Type[mdl.PageTag] = mdl.PageTag,\npage_number: Optional[int] = None,\nlimit: Optional[Annotated[int, ValueRange(1, 100)]] = None,\nparams: Optional[Dict[str, str]] = None,\ntag_type: Optional[types.TagType] = None,\norder: Optional[types.TagOrder] = None,\nrating: Optional[types.Rating] = None,\nmax_post_count: Optional[int] = None,\nsort_parameter: Optional[types.SortParameter] = None,\nsort_direction: Optional[types.SortDirection] = None\n) -&gt; None:\nself.tag_type = tag_type\nself.order = order\nself.rating = rating\nself.max_post_count = max_post_count\nself.sort_parameter = sort_parameter\nself.sort_direction = sort_direction or types.SortDirection.DESC\nsuper().__init__(http_client, url, model, page_number, limit, params)\n</code></pre>"},{"location":"api/paginators/paginators/#sankaku.paginators.paginators.TagPaginator.complete_params","title":"<code>complete_params()</code>","text":"Source code in <code>sankaku/paginators/paginators.py</code> <pre><code>def complete_params(self) -&gt; None:\nsuper().complete_params()\nif self.tag_type is not None:\nself.params[\"types[]\"] = str(self.tag_type.value)\nif self.order is not None:\nself.params[\"order\"] = self.order.value\nif self.rating is not None:\nself.params[\"rating\"] = self.rating.value\nif self.max_post_count is not None:\nself.params[\"amount\"] = str(self.max_post_count)\nif self.sort_parameter is not None:\nself.params.update(\nsortBy=self.sort_parameter.value,\nsortDirection=self.sort_direction.value\n)\n</code></pre>"},{"location":"api/paginators/paginators/#sankaku.paginators.paginators.BookPaginator","title":"<code>sankaku.paginators.paginators.BookPaginator</code>","text":"<p>         Bases: <code>Paginator[mdl.PageBook]</code></p> <p>Paginator used for iteration through book pages.</p> Source code in <code>sankaku/paginators/paginators.py</code> <pre><code>class BookPaginator(Paginator[mdl.PageBook]):\n\"\"\"Paginator used for iteration through book pages.\"\"\"\ndef __init__(\nself,\nhttp_client: HttpClient,\nurl: str,\nmodel: Type[mdl.PageBook] = mdl.PageBook,\npage_number: Optional[int] = None,\nlimit: Optional[Annotated[int, ValueRange(1, 100)]] = None,\nparams: Optional[Dict[str, str]] = None,\norder: Optional[types.BookOrder] = None,\nrating: Optional[types.Rating] = None,\nrecommended_for: Optional[str] = None,\nfavorited_by: Optional[str] = None,\ntags: Optional[List[str]] = None,\nadded_by: Optional[List[str]] = None,\nvoted: Optional[str] = None\n) -&gt; None:\nself.order = order\nself.rating = rating\nself.recommended_for = recommended_for\nself.favorited_by = favorited_by\nself.tags = tags\nself.added_by = added_by\nself.voted = voted\nsuper().__init__(http_client, url, model, page_number, limit, params)\ndef complete_params(self) -&gt; None:\nsuper().complete_params()\nif self.tags is None:\nself.tags = []\nfor k, v in self.__dict__.items():\nif v is None:\ncontinue\nelif k in {\"order\", \"rating\"}:\nself.tags.append(f\"{k}:{v.value}\")\nelif k in {\"recommended_for\", \"voted\"}:\nself.tags.append(f\"{k}:{v}\")\nelif k == \"favorited_by\":\nself.tags.append(f\"fav:{self.favorited_by}\")\nelif k == \"added_by\":\nfor user in self.added_by:  # type: ignore[union-attr]\nself.tags.append(f\"user:{user}\")\nif self.tags:\nself.params[\"tags\"] = \" \".join(self.tags)\n</code></pre>"},{"location":"api/paginators/paginators/#sankaku.paginators.paginators.BookPaginator.__init__","title":"<code>__init__(http_client, url, model=mdl.PageBook, page_number=None, limit=None, params=None, order=None, rating=None, recommended_for=None, favorited_by=None, tags=None, added_by=None, voted=None)</code>","text":"Source code in <code>sankaku/paginators/paginators.py</code> <pre><code>def __init__(\nself,\nhttp_client: HttpClient,\nurl: str,\nmodel: Type[mdl.PageBook] = mdl.PageBook,\npage_number: Optional[int] = None,\nlimit: Optional[Annotated[int, ValueRange(1, 100)]] = None,\nparams: Optional[Dict[str, str]] = None,\norder: Optional[types.BookOrder] = None,\nrating: Optional[types.Rating] = None,\nrecommended_for: Optional[str] = None,\nfavorited_by: Optional[str] = None,\ntags: Optional[List[str]] = None,\nadded_by: Optional[List[str]] = None,\nvoted: Optional[str] = None\n) -&gt; None:\nself.order = order\nself.rating = rating\nself.recommended_for = recommended_for\nself.favorited_by = favorited_by\nself.tags = tags\nself.added_by = added_by\nself.voted = voted\nsuper().__init__(http_client, url, model, page_number, limit, params)\n</code></pre>"},{"location":"api/paginators/paginators/#sankaku.paginators.paginators.BookPaginator.complete_params","title":"<code>complete_params()</code>","text":"Source code in <code>sankaku/paginators/paginators.py</code> <pre><code>def complete_params(self) -&gt; None:\nsuper().complete_params()\nif self.tags is None:\nself.tags = []\nfor k, v in self.__dict__.items():\nif v is None:\ncontinue\nelif k in {\"order\", \"rating\"}:\nself.tags.append(f\"{k}:{v.value}\")\nelif k in {\"recommended_for\", \"voted\"}:\nself.tags.append(f\"{k}:{v}\")\nelif k == \"favorited_by\":\nself.tags.append(f\"fav:{self.favorited_by}\")\nelif k == \"added_by\":\nfor user in self.added_by:  # type: ignore[union-attr]\nself.tags.append(f\"user:{user}\")\nif self.tags:\nself.params[\"tags\"] = \" \".join(self.tags)\n</code></pre>"},{"location":"api/paginators/paginators/#sankaku.paginators.paginators.UserPaginator","title":"<code>sankaku.paginators.paginators.UserPaginator</code>","text":"<p>         Bases: <code>Paginator[mdl.User]</code></p> <p>Paginator used for iteration through user pages.</p> Source code in <code>sankaku/paginators/paginators.py</code> <pre><code>class UserPaginator(Paginator[mdl.User]):\n\"\"\"Paginator used for iteration through user pages.\"\"\"\ndef __init__(\nself,\nhttp_client: HttpClient,\nurl: str,\nmodel: Type[mdl.User] = mdl.User,\npage_number: Optional[int] = None,\nlimit: Optional[Annotated[int, ValueRange(1, 100)]] = None,\nparams: Optional[Dict[str, str]] = None,\norder: Optional[types.UserOrder] = None,\nlevel: Optional[types.UserLevel] = None\n) -&gt; None:\nself.order = order\nself.level = level\nsuper().__init__(http_client, url, model, page_number, limit, params)\ndef complete_params(self) -&gt; None:\nsuper().complete_params()\nif self.order is not None:\nself.params[\"order\"] = self.order.value\nif self.level is not None:\nself.params[\"level\"] = str(self.level.value)\n</code></pre>"},{"location":"api/paginators/paginators/#sankaku.paginators.paginators.UserPaginator.__init__","title":"<code>__init__(http_client, url, model=mdl.User, page_number=None, limit=None, params=None, order=None, level=None)</code>","text":"Source code in <code>sankaku/paginators/paginators.py</code> <pre><code>def __init__(\nself,\nhttp_client: HttpClient,\nurl: str,\nmodel: Type[mdl.User] = mdl.User,\npage_number: Optional[int] = None,\nlimit: Optional[Annotated[int, ValueRange(1, 100)]] = None,\nparams: Optional[Dict[str, str]] = None,\norder: Optional[types.UserOrder] = None,\nlevel: Optional[types.UserLevel] = None\n) -&gt; None:\nself.order = order\nself.level = level\nsuper().__init__(http_client, url, model, page_number, limit, params)\n</code></pre>"},{"location":"api/paginators/paginators/#sankaku.paginators.paginators.UserPaginator.complete_params","title":"<code>complete_params()</code>","text":"Source code in <code>sankaku/paginators/paginators.py</code> <pre><code>def complete_params(self) -&gt; None:\nsuper().complete_params()\nif self.order is not None:\nself.params[\"order\"] = self.order.value\nif self.level is not None:\nself.params[\"level\"] = str(self.level.value)\n</code></pre>"},{"location":"clients/","title":"Introduction","text":"<p>There are several clients present and each of them is has different responsibilities, but for simplicity they all are merged into one client with multiple inheritance - <code>SankakuClient()</code>. If you want to use any specific client, then you should import it explicitly: <code>from sankaku.clients import &lt;client&gt;</code>.</p>"},{"location":"clients/ai-client/","title":"About AIClient","text":"<p>Recently Sankaku Complex developers released feature to generate posts by usage of neural networks. So AIClient is responsible for managing API requests to AI-related content.</p>"},{"location":"clients/ai-client/#note","title":"Note","text":"<p>Because AI is feature for premium users, AI client look a bit poor.</p>"},{"location":"clients/ai-client/#browsing-posts-with-aiclient","title":"Browsing posts with AIClient","text":"<p>For non-premium users there is restriction to directly view posts created by AI:</p> <p></p> <p>But this restriction can be circumvented by sending requests directly via API.</p> <p>Here is example of post browsing, using AIClient:</p> <pre><code>import asyncio\nfrom sankaku.clients import AIClient\nfrom sankaku import types\nasync def main():\nclient = AIClient()\nai_posts = []\nasync for post in client.browse_ai_posts():\nif post.rating is types.Rating.SAFE:  # Filter nsfw content\nai_posts.append(post)\nif len(ai_posts) &gt;= 10:  # For instance, we need to fetch 10 posts\nbreak\nprint(\"\\n\".join(post.file_url for post in ai_posts if post.file_url))\nasyncio.run(main())\n</code></pre>"},{"location":"clients/ai-client/#getting-specific-ai-post","title":"Getting specific AI post","text":"<p>If there is situation when you know ID of the post and want to fetch its data from server, you can do it like this:</p> <pre><code>import asyncio\nfrom sankaku.clients import AIClient\nasync def main():\npost_id: int = 23432  # Here the ID of the post you interested in\nclient = AIClient()\npost = await client.get_ai_post(post_id)\nprint(post.file_url)\nasyncio.run(main())\n</code></pre>"},{"location":"clients/book-client/","title":"About BookClient","text":"<p>BookClient resembles PostClient in terms of functionality. It's because posts and books are strongly related.</p>"},{"location":"clients/book-client/#browsing-books-with-bookclient","title":"Browsing books with BookClient","text":"<p>The following code shows how to browse pages with books:</p> <pre><code>import asyncio\nfrom sankaku.clients import BookClient\nfrom sankaku import types\nasync def main():\nclient = BookClient()\nasync for book in client.browse_books(\nfavorited_by=\"Nigredo\", order=types.BookOrder.POPULARITY\n):\nprint(book.name, book.description)\n# ... Continue fetching books or break\nasyncio.run(main())\n</code></pre>"},{"location":"clients/book-client/#getting-books-related-to-specific-post","title":"Getting books related to specific post","text":"<p>If specific post id has some books as its parents, you can use <code>get_related_books()</code> method to get such books:</p> <pre><code>import asyncio\nfrom sankaku.clients import BookClient\nasync def main():\nclient = BookClient()\npost_id: int = ...\nrelated_books = []\nasync for book in client.get_related_books(post_id):\nrelated_books.append(book)\nasyncio.run(main())\n</code></pre>"},{"location":"clients/book-client/#getting-specific-book-by-its-id","title":"Getting specific book by its ID","text":"<p>If you know specific book ID then you can get remaining parameters. Peculiarity of that method is that it returns the whole book information (including another posts that are part of book):</p> <pre><code>import asyncio\nfrom sankaku.clients import BookClient\nasync def main():\nclient = BookClient()\nbook_id: int = 14562\nbook = await client.get_book(book_id)\nprint(\"\\n\".join(post.file_url for post in book.posts))\nasyncio.run(main())\n</code></pre>"},{"location":"clients/book-client/#about-the-remaining-methods","title":"About the remaining methods","text":"<p>All the remaining methods inside their definitions invoke method <code>browse_books()</code> with certain arguments so there is no need to thoroughly consider them. Also, all the remaining mehtods require authentication.</p>"},{"location":"clients/post-client/","title":"About PostClient","text":"<p>Client for post browsing has several times more methods than other clients. That applies to <code>browse_posts()</code> method too.</p>"},{"location":"clients/post-client/#browsing-posts-with-post-client","title":"Browsing posts with post client","text":"<p>Here simple code snippet with post browsing:</p> <pre><code>import asyncio\nfrom datetime import datetime\nfrom sankaku.clients import PostClient\nfrom sankaku import types\nasync def main():\nclient = PostClient()\nasync for post in client.browse_posts(\ntypes.PostOrder.QUALITY,\n[datetime(2020, 1, 12), datetime(2022, 1, 12)],\ntags=[\"animated\"],\nfile_type=types.FileType.VIDEO,\nrating=types.Rating.SAFE\n):\nprint(post.file_url)\n# ... Continue browsing posts or break\nasyncio.run(main())\n</code></pre>"},{"location":"clients/post-client/#getting-specific-post-by-its-id","title":"Getting specific post by its ID","text":"<p>You can get specific post by its ID like that:</p> <pre><code>import asyncio\nfrom sankaku.clients import PostClient\nasync def main():\npost_id: int = 25742064  # Here the ID of the post you interested in\nclient = PostClient()\npost = await client.get_post(post_id)\nprint(post.file_url)\nasyncio.run(main())\n</code></pre>"},{"location":"clients/post-client/#about-the-remaining-methods","title":"About the remaining methods","text":"<p>Almost all the remaining methods inside their definitions invoke method <code>browse_posts()</code> with certain arguments so there is no need to thoroughly consider them. But it's worth mentioning that methods <code>get_recommended_posts()</code> and <code>get_favorited_posts()</code> require authorization.</p>"},{"location":"clients/tag-client/","title":"About TagClient","text":"<p>Tag client has methods for browsing pages with tags and for fetching specific tag.</p>"},{"location":"clients/tag-client/#browsing-tags-with-tagclient","title":"Browsing tags with TagClient","text":"<p>Unlike AI-generated posts, whose browsing is restricted and can't be parametrized, method <code>browse_tags()</code> can be parametrized in same way as on website:</p> <pre><code>import asyncio\nfrom sankaku.clients import TagClient\nfrom sankaku import types\nasync def main():\nclient = TagClient()\nasync for tag in client.browse_tags(\norder=types.TagOrder.QUALITY,\nsort_parameter=types.SortParameter.POST_COUNT,\nsort_direction=types.SortDirection.DESC\n):\nprint(tag.name, tag.rating, tag.type)\n# ... Continue actions with tags or invoke break\nasyncio.run(main())\n</code></pre>"},{"location":"clients/tag-client/#getting-specific-tag","title":"Getting specific tag","text":"<p>Unlike posts, AI-generated posts or books, specific tag can be returned by its name or id:</p> <pre><code>import asyncio\nfrom sankaku.clients import TagClient\nasync def main():\nclient = TagClient()\ntag_id: int = 100\ntag_name: str = \"mirco_cabbia\"\ntag_by_id = await client.get_tag(tag_id)\ntag_by_name = await client.get_tag(tag_name)\nprint(tag_by_id)\nprint(tag_by_name)\nasyncio.run(main())\n</code></pre>"},{"location":"clients/user-client/","title":"About UserClient","text":"<p>Methods of UserClient enables you browse pages with users or get specific user.</p>"},{"location":"clients/user-client/#browsing-users-with-userclient","title":"Browsing users with UserClient","text":"<p>User browsing can be parametrized by specifying Order rule or level of users:</p> <pre><code>import asyncio\nfrom datetime import datetime\nfrom sankaku.clients import UserClient\nfrom sankaku import types\nasync def main():\nclient = UserClient()\nasync for user in client.browse_users(\ntypes.UserOrder.OLDEST,\ntypes.UserLevel.CONTRIBUTOR\n):\nprint(user.created_at &lt; datetime(2020, 12, 18).astimezone())\n# ... Continue comparing or break\nasyncio.run(main())\n</code></pre>"},{"location":"clients/user-client/#getting-specific-user","title":"Getting specific user","text":"<p>By analogy with <code>get_tag()</code> method you can get information about specific user by its nickname or id:</p> <pre><code>import asyncio\nfrom sankaku.clients import UserClient\nasync def main():\nclient = UserClient()\nuser_id: int = 3242\nuser_name: str = \"reichan\"\nuser_by_id = await client.get_user(user_id)\nuser_by_name = await client.get_user(user_name)\nprint(user_by_id)\nprint(user_by_name)\nasyncio.run(main())\n</code></pre>"}]}